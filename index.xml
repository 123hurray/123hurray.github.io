<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RayXXZhang的博客</title>
    <link>http://blog.123hurray.tk/</link>
    <description>Recent content on RayXXZhang的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyright RayXXZhang</copyright>
    <lastBuildDate>Tue, 15 Sep 2015 20:33:06 +0800</lastBuildDate>
    <atom:link href="http://blog.123hurray.tk/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Windows下PyInstaller的使用教程</title>
      <link>http://blog.123hurray.tk/2015/09/15/pyinstaller/</link>
      <pubDate>Tue, 15 Sep 2015 20:33:06 +0800</pubDate>
      
      <guid>http://blog.123hurray.tk/2015/09/15/pyinstaller/</guid>
      <description>

&lt;p&gt;直接使用Python开发的软件时有许多不方便的地方，如需要安装特定的Python环境，需要安装依赖库。为了便于部署，需要将Python源代码编译成可执行文件，编译后的可执行文件就能脱离python环境运行了。&lt;/p&gt;

&lt;h1 id=&#34;安装:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;将py编译成可执行文件需要使用&lt;a href=&#34;https://github.com/pyinstaller/&#34;&gt;PyInstaller&lt;/a&gt;，需要注意，从百度搜索到的下载链接来自SourceForge，而PyInstaller的开发似乎已经转到Github上去了，因此从SourceForge上下载的版本不是最新的。&lt;/p&gt;

&lt;p&gt;目前最新的PyInstaller版本是2.1，最方便的安装方式是通过&lt;code&gt;pip&lt;/code&gt;使用如下命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install pyinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以通过&lt;a href=&#34;https://github.com/pyinstaller/pyinstaller/releases&#34;&gt;下载&lt;/a&gt;源代码编译方式安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，使用如下命令可以确认版本号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pyinstaller --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示&lt;code&gt;Error: Python 2.6+ on Windows support need pywin32&lt;/code&gt;，则说明当前没有安装&lt;a href=&#34;http://sourceforge.net/projects/pywin32/files/pywin32/&#34;&gt;pywin32&lt;/a&gt;，安装后即可正常运行PyInstaller。
安装pywin32时需要注意，pywin32的版本和本机Python位数和版本必须相同。&lt;/p&gt;

&lt;h1 id=&#34;简单使用:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;简单使用&lt;/h1&gt;

&lt;p&gt;最简单的使用方式是运行&lt;code&gt;pyinstaller myscript.py&lt;/code&gt;来生成可执行文件，其中&lt;code&gt;myscript.py&lt;/code&gt;是需要编译成可执行文件的源代码。
通过这种方式生成的可执行文件默认位于当前文件夹的dist目录下的myscript目录中，该目录下除了有exe文件外，还有若干个其他文件，这些文件都是运行时必须的。
编译完成后可以删除build文件夹，该文件夹存放的是编译过程中的生成的临时文件&lt;/p&gt;

&lt;p&gt;如果希望编译出的exe文件不依赖其他文件，可以添加&lt;code&gt;-F&lt;/code&gt;选项：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pyinstaller -F myscript.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;编译出的单独的exe文件在启动时速度上略慢于编译成文件夹方式。因为在执行单独的exe时会将资源先释放到临时文件夹中再执行。&lt;/p&gt;

&lt;h1 id=&#34;常用选项:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;常用选项&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;distpath=path_to_executable, -o path_to_executable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;指定生成的可执行文件存放的目录，默认存放在dist目录下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;workpath=path_to_work_files&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;指定编译中临时文件存放的目录，默认存放在build目录下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;clean&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;清理编译时的临时文件&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-F, &amp;ndash;onefile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成单独的exe文件而不是文件夹&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-d, &amp;ndash;debug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编译为debug模式，有助于运行中获取日志信息&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;version-file=version_text_file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为exe文件添加版本信息，版本信息可以通过运行&lt;code&gt;pyi-grab_version&lt;/code&gt;加上要获取版本信息的exe文件的路径来生成，生成后的版本信息文件可以按需求修改并作为&lt;code&gt;--version-file&lt;/code&gt;的参数添加到要生成的exe文件中去&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;i &lt;FILE.ico&gt;, -i &lt;FILE.exe,ID&gt;, &amp;ndash;icon=&lt;FILE.ico&gt;, &amp;ndash;icon=&lt;FILE.exe,ID&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为exe文件添加图标，可以指定图标路径或者从已存在的exe文件中抽取特定的ID的图标作为要生成的exe文件的图标&lt;/p&gt;

&lt;p&gt;另外，还可以通过spec文件来生成可执行文件，运行&lt;code&gt;pyi-makespec options script [script ...]&lt;/code&gt;可以生成spec文件，修改spec文件后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pyinstaller specfile

或者

pyi-build specfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以生成可执行文件了。&lt;/p&gt;

&lt;p&gt;spec文件方式生成可执行文件提供了更多的定制选项，包括自定义python库的位置，要打包的其他文件路径等等。&lt;/p&gt;

&lt;h2 id=&#34;更多:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;更多&lt;/h2&gt;

&lt;p&gt;更多的使用选项及错误解决方法可以参照PyInstaller的&lt;a href=&#34;http://pythonhosted.org/PyInstaller/&#34;&gt;官方帮助文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>POJ1003解题报告</title>
      <link>http://blog.123hurray.tk/2015/09/14/poj1003/</link>
      <pubDate>Mon, 14 Sep 2015 21:35:12 +0800</pubDate>
      
      <guid>http://blog.123hurray.tk/2015/09/14/poj1003/</guid>
      <description>

&lt;h1 id=&#34;题目概览:2e98549788b10e1ae8406221df07f9c6&#34;&gt;题目概览&lt;/h1&gt;

&lt;h2 id=&#34;标题:2e98549788b10e1ae8406221df07f9c6&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;487-3279&lt;/p&gt;

&lt;h2 id=&#34;要求:2e98549788b10e1ae8406221df07f9c6&#34;&gt;要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Time Limit: 1000MS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory Limit: 10000K&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题目描述:2e98549788b10e1ae8406221df07f9c6&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We&amp;rsquo;re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; = &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt; card lengths. In general you can make n cards overhang by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; + &amp;hellip; + 1/(n + 1) card lengths, where the top card overhangs the second by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, the second overhangs tha third by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;, the third overhangs the fourth by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;, etc., and the bottom card overhangs the table by 1/(n + 1). This is illustrated in the figure below.&lt;/p&gt;

&lt;h2 id=&#34;输入:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;The input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. Each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits.&lt;/p&gt;

&lt;h2 id=&#34;输出:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输出&lt;/h2&gt;

&lt;p&gt;For each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. Use the exact output format shown in the examples.&lt;/p&gt;

&lt;h2 id=&#34;输入示例:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输入示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;1.00&lt;/p&gt;

&lt;p&gt;3.71&lt;/p&gt;

&lt;p&gt;0.04&lt;/p&gt;

&lt;p&gt;5.19&lt;/p&gt;

&lt;p&gt;0.00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;输出示例:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输出示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;3 card(s)&lt;/p&gt;

&lt;p&gt;61 card(s)&lt;/p&gt;

&lt;p&gt;1 card(s)&lt;/p&gt;

&lt;p&gt;273 card(s)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;解题报告:2e98549788b10e1ae8406221df07f9c6&#34;&gt;解题报告&lt;/h1&gt;

&lt;h2 id=&#34;分析:2e98549788b10e1ae8406221df07f9c6&#34;&gt;分析&lt;/h2&gt;

&lt;p&gt;本题较简单，可以采用map+vector的方式提高效率，vector用于保存原始的数据顺序，map可以根据数据大小自动排序。&lt;/p&gt;

&lt;p&gt;在计算的时候可以将每一步的计算结果与map的迭代器里的数比较，如果符合，则将取出map中的下一个数，这样能仅进行一遍计算就能得到全部结果。&lt;/p&gt;

&lt;p&gt;最后输出的时候键的顺序采用vector里保存的顺序（即原始顺序），值则采用map中的值。&lt;/p&gt;

&lt;h2 id=&#34;源码:2e98549788b10e1ae8406221df07f9c6&#34;&gt;源码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;map&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
int main() {
    string item;
    vector&amp;lt;double&amp;gt; input;
    map&amp;lt;double, int&amp;gt; sorted;
    double num;
    while (true) {
        cin &amp;gt;&amp;gt; item;
        if (item == &amp;quot;0.00&amp;quot;) {
            break;
        }
        num = item[0] - &#39;0&#39; + (item[2] - &#39;0&#39;) * 0.1 + (item[3] - &#39;0&#39;) * 0.01;
        input.push_back(num);
        sorted.insert(make_pair(num, 0));
    }
    double result = 0;
    map&amp;lt;double, int&amp;gt;::iterator it = sorted.begin();
    for (int i = 2; it != sorted.end(); ++i) {
        result += 1.0 / i;
        while (result &amp;gt; it-&amp;gt;first) {
            it-&amp;gt;second = i - 1;
            ++it;
            if (it == sorted.end()) {
                break;
            }
        }
    }
    for (vector&amp;lt;double&amp;gt;::iterator itv = input.begin(); itv != input.end(); ++itv) {
        cout &amp;lt;&amp;lt; sorted[*itv] &amp;lt;&amp;lt; &amp;quot; card(s)&amp;quot; &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>POJ1002解题报告</title>
      <link>http://blog.123hurray.tk/2015/09/14/poj1002/</link>
      <pubDate>Mon, 14 Sep 2015 19:05:45 +0800</pubDate>
      
      <guid>http://blog.123hurray.tk/2015/09/14/poj1002/</guid>
      <description>

&lt;h1 id=&#34;题目概览:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;题目概览&lt;/h1&gt;

&lt;h2 id=&#34;标题:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;487-3279&lt;/p&gt;

&lt;h2 id=&#34;要求:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Time Limit: 2000MS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory Limit: 65536K&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题目描述:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;Businesses like to have memorable telephone numbers. One way to make a telephone number memorable is to have it spell a memorable word or phrase. For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP. Sometimes only part of the number is used to spell a word. When you get back to your hotel tonight you can order a pizza from Gino&amp;rsquo;s by dialing 310-GINO. Another way to make a telephone number memorable is to group the digits in a memorable way. You could order your pizza from Pizza Hut by calling their &amp;lsquo;three tens&amp;rsquo; number 3-10-10-10.&lt;/p&gt;

&lt;p&gt;The standard form of a telephone number is seven decimal digits with a hyphen between the third and fourth digits (e.g. 888-1200). The keypad of a phone supplies the mapping of letters to numbers, as follows:&lt;/p&gt;

&lt;p&gt;A, B, and C map to 2
D, E, and F map to 3
G, H, and I map to 4
J, K, and L map to 5
M, N, and O map to 6
P, R, and S map to 7
T, U, and V map to 8
W, X, and Y map to 9&lt;/p&gt;

&lt;p&gt;There is no mapping for Q or Z. Hyphens are not dialed, and can be added and removed as necessary. The standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010.&lt;/p&gt;

&lt;p&gt;Two telephone numbers are equivalent if they have the same standard form. (They dial the same number.)&lt;/p&gt;

&lt;p&gt;Your company is compiling a directory of telephone numbers from local businesses. As part of the quality control process you want to check that no two (or more) businesses in the directory have the same telephone number.&lt;/p&gt;

&lt;h2 id=&#34;输入:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;The input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters.&lt;/p&gt;

&lt;h2 id=&#34;输出:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输出&lt;/h2&gt;

&lt;p&gt;Generate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line:&lt;/p&gt;

&lt;p&gt;No duplicates.&lt;/p&gt;

&lt;h2 id=&#34;输入示例:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输入示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;12&lt;/p&gt;

&lt;p&gt;4873279&lt;/p&gt;

&lt;p&gt;ITS-EASY&lt;/p&gt;

&lt;p&gt;888-4567&lt;/p&gt;

&lt;p&gt;3-10-10-10&lt;/p&gt;

&lt;p&gt;888-GLOP&lt;/p&gt;

&lt;p&gt;TUT-GLOP&lt;/p&gt;

&lt;p&gt;967-11-11&lt;/p&gt;

&lt;p&gt;310-GINO&lt;/p&gt;

&lt;p&gt;F101010&lt;/p&gt;

&lt;p&gt;888-1200&lt;/p&gt;

&lt;p&gt;-4-8-7-3-2-7-9-&lt;/p&gt;

&lt;p&gt;487-3279&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;输出示例:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输出示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;310-1010 2&lt;/p&gt;

&lt;p&gt;487-3279 4&lt;/p&gt;

&lt;p&gt;888-4567 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;解题报告:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;解题报告&lt;/h1&gt;

&lt;h2 id=&#34;分析:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;分析&lt;/h2&gt;

&lt;p&gt;需要将输入还原成数字，可以有几种方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以构建字符和数字映射的哈希表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;table[&#39;A&#39;] = table[&#39;B&#39;] = table[&#39;C&#39;] = 1;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以使用 &lt;code&gt;switch&lt;/code&gt; 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;switch(oneChar) {
    case &#39;A&#39;:
    case &#39;B&#39;:
    case &#39;C&#39;:
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要将解析出的数字放入哈希表或者数组中以便统计出现个数。如果使用C++的map，则最后输出时还能实现自动的排序。&lt;/p&gt;

&lt;h2 id=&#34;c-的map容器学习:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;C++的map容器学习&lt;/h2&gt;

&lt;h3 id=&#34;头文件:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;头文件&lt;/h3&gt;

&lt;p&gt;使用map需引用map头文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;map&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;声明:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;声明&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map&amp;lt;int, string&amp;gt; map1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11前map的初始化只能通过[]下标操作或者insert函数实现，C++11引入了新的map初始化方式，可以通过如下方式进行初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map&amp;lt;int, string&amp;gt; map1 = {{1, &amp;quot;A&amp;quot;}, {2, &amp;quot;B&amp;quot;}};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;插入:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;插入&lt;/h3&gt;

&lt;p&gt;插入操作可以使用[]下标操作或者insert函数。两者的区别是当要的键之前存在时，[]会更新原来的值，而insert则不会更新，并且返回值为 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;insert有很多个重载，其中最常用的一个重载接受一个pair类型作为参数，可以使用 &lt;code&gt;make_pair&lt;/code&gt; 来创建pair：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map1.insert(make_pair(1, &amp;quot;A&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11可以通过emplace函数添加新元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map1.emplace(1, &amp;quot;A&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查找:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;查找&lt;/h3&gt;

&lt;p&gt;查找通过find函数。find函数返回一个迭代器，通过判断迭代器是否为end来确认是否查找到了指定的元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map&amp;lt;int, string&amp;gt;::iterator it = map1.find(1);
if(it != map1.end()) {
	// 找到相应元素	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;访问:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;访问&lt;/h3&gt;

&lt;p&gt;通过使用[]下标操作访问元素，c++11可以通过at函数来访问元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的一点是使用[]下标操作有副作用，即如果该键不存在，会在该键上插入一个有默认值的元素。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;删除:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;删除&lt;/h3&gt;

&lt;p&gt;删除使用earse函数，传入要删除的键即可&lt;/p&gt;

&lt;h3 id=&#34;遍历:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;遍历&lt;/h3&gt;

&lt;p&gt;map通过迭代器遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(map&amp;lt;int, string&amp;gt;::iterator it = map1.begin();it != map1.end(); ++it) {
	// it-&amp;gt;first 是键
	// it-&amp;gt;second 是值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c++11还能通过以下方法遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(auto it: map1) {
	// it.first 是键
	// it.second 是值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其他:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;其他&lt;/h3&gt;

&lt;p&gt;其他函数及详细说明可以参考&lt;a href=&#34;http://www.cplusplus.com/reference/map/map/&#34;&gt;C++ map官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;poj的一些注意事项:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;POJ的一些注意事项&lt;/h2&gt;

&lt;h2 id=&#34;编译:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;C++的编译可以使用POJ提交选项中的C++或者G++编译器，其中C++是VC++的编译器，G++是GNU的编译器。两者均不支持C++11特性。
有些题目使用C++能通过，但G++会超时，有时又相反，因此超时或内存占用过大的情况下可以试着换一下编译器。&lt;/p&gt;

&lt;h2 id=&#34;io:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;IO&lt;/h2&gt;

&lt;p&gt;C++的cin和cout的运行时间比C中的scanf和printf要长，容易超时。且在本题中按字符读取而不是按字符串读取必定超时（未验证，该说法来自&lt;a href=&#34;http://blog.csdn.net/lyy289065406/article/details/6647348&#34;&gt;POJ1002-487-3279&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;stl:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;STL&lt;/h2&gt;

&lt;p&gt;使用STL效率会降低一些&lt;/p&gt;

&lt;h1 id=&#34;源码:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;源码&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;map&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;iomanip&amp;gt;
using namespace std;
class PhoneNumberList {
public:
	explicit PhoneNumberList() :numMap() { };
	void add(string numStr) {
		int number = parse(numStr);
		map&amp;lt;int, int&amp;gt;::iterator it = numMap.find(number);
		if (it == numMap.end()) {
			numMap.insert(make_pair(number, 1));
		}
		else {
			it-&amp;gt;second++;
		}

	}
	friend ostream &amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, PhoneNumberList &amp;amp;list) {
		bool duplicate = false;
		for (map&amp;lt;int, int&amp;gt;::iterator i = list.numMap.begin(); i != list.numMap.end(); ++i) {
			if (i-&amp;gt;second != 1) {
				os &amp;lt;&amp;lt; setfill(&#39;0&#39;) &amp;lt;&amp;lt; setfill(&#39;0&#39;) &amp;lt;&amp;lt; setw(3) &amp;lt;&amp;lt; i-&amp;gt;first / 10000 &amp;lt;&amp;lt; &amp;quot;-&amp;quot; &amp;lt;&amp;lt; setfill(&#39;0&#39;) &amp;lt;&amp;lt; setw(4) &amp;lt;&amp;lt; i-&amp;gt;first % 10000 &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; endl;
				duplicate = true;
			}
		}
		if (duplicate == false) {
			os &amp;lt;&amp;lt; &amp;quot;No duplicates.&amp;quot; &amp;lt;&amp;lt; endl;
		}
		return os;
	};
private:
	map&amp;lt;int, int&amp;gt; numMap;
	int parse(string numStr) const {
		int result = 0;
		int length = numStr.length();
		for (int i = 0; i &amp;lt; length; ++i) {
			char *c = &amp;amp;numStr[i];
			switch (*c) {
			case &#39;A&#39;:
			case &#39;B&#39;:
			case &#39;C&#39;:
				result = result * 10 + 2;
				break;
			case &#39;D&#39;:
			case &#39;E&#39;:
			case &#39;F&#39;:
				result = result * 10 + 3;
				break;
			case &#39;G&#39;:
			case &#39;H&#39;:
			case &#39;I&#39;:
				result = result * 10 + 4;
				break;
			case &#39;J&#39;:
			case &#39;K&#39;:
			case &#39;L&#39;:
				result = result * 10 + 5;
				break;
			case &#39;M&#39;:
			case &#39;N&#39;:
			case &#39;O&#39;:
				result = result * 10 + 6;
				break;
			case &#39;P&#39;:
			case &#39;R&#39;:
			case &#39;S&#39;:
				result = result * 10 + 7;
				break;
			case &#39;T&#39;:
			case &#39;U&#39;:
			case &#39;V&#39;:
				result = result * 10 + 8;
				break;
			case &#39;W&#39;:
			case &#39;X&#39;:
			case &#39;Y&#39;:
				result = result * 10 + 9;
				break;
			default:
				if (*c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *c &amp;lt;= &#39;9&#39;) {
					result = result * 10 + *c - &#39;0&#39;;
				}
				break;
			}
		}
		return result;
	}
};
int main() {
	int lines;
	PhoneNumberList phoneNumberList;
	cin &amp;gt;&amp;gt; lines;
	string item;
	for (int i = 0; i &amp;lt; lines; ++i) {
		cin &amp;gt;&amp;gt; item;
		phoneNumberList.add(item);
	}
	cout &amp;lt;&amp;lt; phoneNumberList;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考页面:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;参考页面&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://my.oschina.net/skyhacker2/blog/392832&#34;&gt;C++11遍历map&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.itpub.net/16856446/viewspace-626583/&#34;&gt;C++ map[ ]=与insert操作不同&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/liucanrui/article/details/6591029&#34;&gt;C++学习之map类型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/map/map/&#34;&gt;C++ map官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Hugo搭建博客</title>
      <link>http://blog.123hurray.tk/2015/09/14/first/</link>
      <pubDate>Mon, 14 Sep 2015 18:57:07 +0800</pubDate>
      
      <guid>http://blog.123hurray.tk/2015/09/14/first/</guid>
      <description>&lt;p&gt;终于下决心开个博客，之前试过一次，但是太懒，基本没写什么，而且懒得维护服务器。所以这次博客选择用静态页面的方法搭建，静态博客的好处是能专注于内容本身而不是服务器的维护工作。&lt;/p&gt;

&lt;p&gt;假期花了两天时间完成了建立博客的前期准备工作，在此分享一下其中的心得体会：&lt;/p&gt;

&lt;p&gt;博客的托管方面选择的是 &lt;em&gt;Github Pages&lt;/em&gt; ， &lt;em&gt;Github Pages&lt;/em&gt; 可以存放静态的网页，通常被用于架设开源项目的主页以及个人技术博客。
搭建博客以及选择托管在Github上的主要是因为曾经听一个互联网创业公司的创始人说过，写博客是一种很好的习惯，可以记录下自己所学过的知识。这对未来的求职和工作都有帮助。
而Github作为目前最大的开源社区，是技术交流的绝佳平台，相比于国内使用较多的CSDN博客及博客园，Github博客以Github的个人主页更能体现出一个人完整的技术水平。&lt;/p&gt;

&lt;p&gt;关于 &lt;em&gt;Github Pages&lt;/em&gt; 的使用，官方有详细的&lt;a href=&#34;https://help.github.com/categories/github-pages-basics/&#34;&gt;教程&lt;/a&gt;。
官方推荐的架设博客的方式是使用&lt;a href=&#34;https://github.com/jekyll/jekyll&#34;&gt;Jekyll&lt;/a&gt;，不过在看了网上一些对静态博客搭建软件的比较后（&lt;a href=&#34;http://www.zhihu.com/question/20962496&#34;&gt;如何在 GitHub 上写博客？&lt;/a&gt;），最终决定使用Hugo作为搭建博客的工具。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;使用Golang开发，windows版本就一个exe文件，使用方便，并且Github上有许多Hugo的UI主体可供使用。&lt;/p&gt;

&lt;p&gt;在学习使用Hugo的过程中，参考了&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;这篇博文。作者比较详细的说明了如何使用Hugo搭建一个静态博客。
在这里就不详细叙述了，有兴趣可以参考该博文。&lt;/p&gt;

&lt;p&gt;Hugo和Jekyll等软件一样也选择了markdown作为博文的写作格式，这点让我比较喜欢，markdown的写作能在生成比较优雅的外观的同时兼顾源文件的简洁，非常适合技术文章的使用。
尝试了一下Hugo对markdown特性的支持，对标准markdown的支持很好，并且还支持部分&lt;a href=&#34;https://help.github.com/articles/github-flavored-markdown/&#34;&gt;Github flavored markdown&lt;/a&gt;的特性。在此也归纳一下Github官方的markdown教程以便日后查询：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/markdown-basics/&#34;&gt;Markdown basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://guides.github.com/features/mastering-markdown/&#34;&gt;Mastering markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/github-flavored-markdown/&#34;&gt;Github flavored markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Hugo主题选择方面，一个名为&lt;a href=&#34;https://github.com/pdevty/polymer&#34;&gt;Polymer&lt;/a&gt;的主题让我眼前一亮。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/pdevty/polymer/blob/master/images/tn.png?raw=true&#34; alt=&#34;Hugo的Polymer主题&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;从Polymer这个名字一眼就可以看出是来自Google的&lt;a href=&#34;https://www.polymer-project.org/1.0/&#34;&gt;Polymer项目&lt;/a&gt;。
作为这两年在Google I/O大会上提及的前端开发框架，它使用了许多新的技术，如web components，shadow DOM等等，把html的一些基础组件封装成了一些十分方便使用的控件，样式优雅开发简单。
仔细看了一下Hugo的Polymer主题的外观以及逻辑，觉得还是有一些小问题需要改进的，比较明显的就是文章页导航按钮和底栏出现了错位。因此，我决定学习一下Google Polymer的使用方法并且把主题中的这些小错误改过来。&lt;/p&gt;

&lt;p&gt;通过对Google Polymer文档的学习以及Polymer主题源码的阅读和调试，找到发生错位的原因是 &lt;code&gt;layouts/partials/content.html&lt;/code&gt; 文件中未将文章正文部分用 &lt;code&gt;&amp;lt;paper-item&amp;gt;&lt;/code&gt; 标签包裹，而导航栏及底栏都使用了 &lt;code&gt;&amp;lt;paper-item&amp;gt;&lt;/code&gt; 标签，
因此导致了html的解析问题，使得正文部分的高度被忽略，所以原本应该显示在底部的底栏发生了显示上的错位。&lt;/p&gt;

&lt;p&gt;除此之外，还在主题上加入了各大网站个人主页链接的自定义排序功能，并且加上的新浪微博的图标。修改了 &lt;strong&gt;标签&lt;/strong&gt; ， &lt;strong&gt;主题&lt;/strong&gt; 两个页面，添加了自定义预设文本的选项，修改了字体大小等细节。
由于修改基于从原项目folk出的新项目上，因此所有的修改都可以在&lt;a href=&#34;https://github.com/123hurray/polymer/&#34;&gt;github.com/123hurray/polymer&lt;/a&gt;的提交记录看到。&lt;/p&gt;

&lt;p&gt;以上工作完成后，基本的准备工作就算结束了。随着这篇博文的发布，博客就算正式建立了。近期的博客发布计划主要是在Android开发中的一些心得及备忘，&lt;a href=&#34;https://poj.org/&#34;&gt;POJ&lt;/a&gt;题目的解题心得等等。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>