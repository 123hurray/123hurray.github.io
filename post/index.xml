<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on RayXXZhang的博客</title>
    <link>http://blog.rayxxzhang.com/post/</link>
    <description>Recent content in Posts on RayXXZhang的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyright RayXXZhang</copyright>
    <lastBuildDate>Mon, 29 Feb 2016 13:51:16 +0800</lastBuildDate>
    <atom:link href="http://blog.rayxxzhang.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>nsq源码阅读笔记之nsqd（四）——Channel</title>
      <link>http://blog.rayxxzhang.com/2016/02/29/nsqd_source_4_channels/</link>
      <pubDate>Mon, 29 Feb 2016 13:51:16 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2016/02/29/nsqd_source_4_channels/</guid>
      <description>

&lt;p&gt;与&lt;strong&gt;Channel&lt;/strong&gt;相关的代码主要位于&lt;code&gt;nsqd/channel.go&lt;/code&gt;, &lt;code&gt;nsqd/nsqd.go&lt;/code&gt;中。&lt;/p&gt;

&lt;h1 id=&#34;channel与topic的关系:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;Channel与Topic的关系&lt;/h1&gt;

&lt;p&gt;Channel是消费者订阅特定Topic的一种抽象。对于发往Topic的消息，nsqd向该Topic下的所有Channel投递消息，
而同一个Channel只投递一次，Channel下如果存在多个消费者，则随机选择一个消费者做投递。这种投递方式可以被用作消费者负载均衡。&lt;/p&gt;

&lt;p&gt;Channel从属于特定Topic，可以认为是Topic的下一级。在同一个Topic之下可以有零个或多个Channel。
和Topic一样，Channel同样有永久和临时之分，永久的Channel只能通过显式删除销毁，临时的Channel在最后一个消费者断开连接的时候被销毁。&lt;/p&gt;

&lt;p&gt;与服务于生产者的Topic不同，Channel直接面向消费者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;生产者 -&amp;gt; 消息 -&amp;gt; Topic -&amp;gt; Channel -&amp;gt; 消费者1
                       -&amp;gt; Channel2 -&amp;gt; 消费者2
                       -&amp;gt; Channel3 -&amp;gt; 消费者3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码上Channel和Topic有许多相似之处，对于和Topic相同或者相似的部分，以下不再赘述，可以参考Topic相关博文。&lt;/p&gt;

&lt;h1 id=&#34;channel的创建:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;Channel的创建&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewChannel(topicName string, channelName string, ctx *context,
	deleteCallback func(*Channel)) *Channel {

	c := &amp;amp;Channel{
		topicName:      topicName,
		name:           channelName,
		memoryMsgChan:  make(chan *Message, ctx.nsqd.getOpts().MemQueueSize),
		clientMsgChan:  make(chan *Message),
		exitChan:       make(chan int),
		clients:        make(map[int64]Consumer),
		deleteCallback: deleteCallback,
		ctx:            ctx,
	}
	if len(ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles) &amp;gt; 0 {
		c.e2eProcessingLatencyStream = quantile.New(
			ctx.nsqd.getOpts().E2EProcessingLatencyWindowTime,
			ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles,
		)
	}

	c.initPQ()

	if strings.HasSuffix(channelName, &amp;quot;#ephemeral&amp;quot;) {
		c.ephemeral = true
		c.backend = newDummyBackendQueue()
	} else {
		// backend names, for uniqueness, automatically include the topic...
		backendName := getBackendName(topicName, channelName)
		c.backend = newDiskQueue(backendName,
			ctx.nsqd.getOpts().DataPath,
			ctx.nsqd.getOpts().MaxBytesPerFile,
			int32(minValidMsgLength),
			int32(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,
			ctx.nsqd.getOpts().SyncEvery,
			ctx.nsqd.getOpts().SyncTimeout,
			ctx.nsqd.getOpts().Logger)
	}

	go c.messagePump()

	c.ctx.nsqd.Notify(c)

	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel和Topic在创建的时候都会初始化结构，初始化backend，创建消息循环，
不同的是Channel在创建时多了给&lt;code&gt;e2eProcessingLatencyStream&lt;/code&gt;赋值的以及&lt;code&gt;initPQ&lt;/code&gt;部分。&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;e2eProcessingLatencyStream&lt;/code&gt;主要用于统计消息投递的延迟等，将在以后的博文中叙述。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) initPQ() {
	pqSize := int(math.Max(1, float64(c.ctx.nsqd.getOpts().MemQueueSize)/10))

	c.inFlightMessages = make(map[MessageID]*Message)
	c.deferredMessages = make(map[MessageID]*pqueue.Item)

	c.inFlightMutex.Lock()
	c.inFlightPQ = newInFlightPqueue(pqSize)
	c.inFlightMutex.Unlock()

	c.deferredMutex.Lock()
	c.deferredPQ = pqueue.New(pqSize)
	c.deferredMutex.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;initPQ&lt;/code&gt;函数创建了两个字典&lt;code&gt;inFlightMessages&lt;/code&gt;、&lt;code&gt;deferredMessages&lt;/code&gt;和两个队列&lt;code&gt;inFlightPQ&lt;/code&gt;、&lt;code&gt;deferredPQ&lt;/code&gt;。
在nsq中inFlight指的是正在投递但还没确认投递成功的消息，defferred指的是投递失败，等待重新投递的消息。
&lt;code&gt;initPQ&lt;/code&gt;创建的字典和队列主要用于索引和存放这两类消息。其中两个字典使用消息ID作索引。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inFlightPQ&lt;/code&gt;使用&lt;code&gt;newInFlightPqueue&lt;/code&gt;初始化，&lt;code&gt;InFlightPqueue&lt;/code&gt;位于&lt;code&gt;nsqd\in_flight_pqueue.go&lt;/code&gt;。
&lt;code&gt;nsqd\in_flight_pqueue.go&lt;/code&gt;是nsq实现的一个优先级队列，提供了常用的队列操作，值得学习。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;deferredPQ&lt;/code&gt;使用&lt;code&gt;pqueue.New&lt;/code&gt;初始化，&lt;code&gt;pqueue&lt;/code&gt;位于&lt;code&gt;nsqd\pqueue.go&lt;/code&gt;，也是一个优先级队列。&lt;/p&gt;

&lt;h1 id=&#34;待投递消息进入channel:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;待投递消息进入Channel&lt;/h1&gt;

&lt;p&gt;在分析Topic时提到，消息进入Topic的消息循环后会被投递到该Topic下所有的Channel，由Channel的&lt;code&gt;PutMessage&lt;/code&gt;函数进行处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PutMessage writes a Message to the queue
func (c *Channel) PutMessage(m *Message) error {
	c.RLock()
	defer c.RUnlock()
	if atomic.LoadInt32(&amp;amp;c.exitFlag) == 1 {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}
	err := c.put(m)
	if err != nil {
		return err
	}
	atomic.AddUint64(&amp;amp;c.messageCount, 1)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PutMessage&lt;/code&gt;判断当前Channel是否已经被销毁，若未销毁，则调用&lt;code&gt;put&lt;/code&gt;函数进行处理，最后，自增消息计数器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) put(m *Message) error {
	select {
	case c.memoryMsgChan &amp;lt;- m:
	default:
		b := bufferPoolGet()
		err := writeMessageToBackend(b, m, c.backend)
		bufferPoolPut(b)
		c.ctx.nsqd.SetHealth(err)
		if err != nil {
			c.ctx.nsqd.logf(&amp;quot;CHANNEL(%s) ERROR: failed to write message to backend - %s&amp;quot;,
				c.name, err)
			return err
		}
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel的&lt;code&gt;put&lt;/code&gt;函数与Topic的同名函数相似，可以参考Topic。&lt;/p&gt;

&lt;h1 id=&#34;channel对消息的处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;Channel对消息的处理&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// messagePump reads messages from either memory or backend and sends
// messages to clients over a go chan
func (c *Channel) messagePump() {
	var msg *Message
	var buf []byte
	var err error

	for {
		// do an extra check for closed exit before we select on all the memory/backend/exitChan
		// this solves the case where we are closed and something else is draining clientMsgChan into
		// backend. we don&#39;t want to reverse that
		if atomic.LoadInt32(&amp;amp;c.exitFlag) == 1 {
			goto exit
		}

		select {
		case msg = &amp;lt;-c.memoryMsgChan:
		case buf = &amp;lt;-c.backend.ReadChan():
			msg, err = decodeMessage(buf)
			if err != nil {
				c.ctx.nsqd.logf(&amp;quot;ERROR: failed to decode message - %s&amp;quot;, err)
				continue
			}
		case &amp;lt;-c.exitChan:
			goto exit
		}

		msg.Attempts++

		atomic.StoreInt32(&amp;amp;c.bufferedCount, 1)
		c.clientMsgChan &amp;lt;- msg
		atomic.StoreInt32(&amp;amp;c.bufferedCount, 0)
		// the client will call back to mark as in-flight w/ its info
	}

exit:
	c.ctx.nsqd.logf(&amp;quot;CHANNEL(%s): closing ... messagePump&amp;quot;, c.name)
	close(c.clientMsgChan)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入Channel的消息在&lt;code&gt;messagePump&lt;/code&gt;函数中处理，该函数也与Topic的同名函数相似：
消息都从memory和backend两个来源接收，然后解码消息后处理。与Topic不同的是，channel在投递消息前，
会自增&lt;code&gt;msg.Attempts&lt;/code&gt;，该变量用于保存投递尝试的次数。&lt;/p&gt;

&lt;p&gt;在消息投递前会将&lt;code&gt;bufferedCount&lt;/code&gt;置为1，在投递后置为0。该变量在&lt;code&gt;Depth&lt;/code&gt;函数中被调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) Depth() int64 {
	return int64(len(c.memoryMsgChan)) + c.backend.Depth() + int64(atomic.LoadInt32(&amp;amp;c.bufferedCount))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Deepth&lt;/code&gt;函数返回内存，磁盘以及正在投递的消息数量之和，也就是尚未投递成功的消息数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;函数在投递消息时将消息送入&lt;code&gt;clientMsgChan&lt;/code&gt;，随后被&lt;code&gt;nsqd\protocol_v2.go&lt;/code&gt;的&lt;code&gt;messagePump&lt;/code&gt;函数处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// nsqd\protocol_v2.go  messagePump Line 303
case msg, ok := &amp;lt;-clientMsgChan:
    if !ok {
        goto exit
    }

    if sampleRate &amp;gt; 0 &amp;amp;&amp;amp; rand.Int31n(100) &amp;gt; sampleRate {
        continue
    }

    subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)
    client.SendingMessage()
    err = p.SendMessage(client, msg, &amp;amp;buf)
    if err != nil {
        goto exit
    }
    flushed = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在protocolV2的&lt;code&gt;messagePump&lt;/code&gt;函数中，消息被通过投送到相应消费者。
投递时首先调用Channel的&lt;code&gt;StartInFlightTimeout&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) StartInFlightTimeout(msg *Message, clientID int64, timeout time.Duration) error {
	now := time.Now()
	msg.clientID = clientID
	msg.deliveryTS = now
	msg.pri = now.Add(timeout).UnixNano()
	err := c.pushInFlightMessage(msg)
	if err != nil {
		return err
	}
	c.addToInFlightPQ(msg)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数填充消息的消费者ID、投送时间、优先级，然后调用&lt;code&gt;pushInFlightMessage&lt;/code&gt;函数将消息放入&lt;code&gt;inFlightMessages&lt;/code&gt;字典中。
最后调用&lt;code&gt;addToInFlightPQ&lt;/code&gt;将消息放入&lt;code&gt;inFlightPQ&lt;/code&gt;队列中。&lt;/p&gt;

&lt;p&gt;至此，消息投递流程完成，接下来需要等待消费者对投送结果的反馈。消费者通过发送&lt;code&gt;FIN&lt;/code&gt;、&lt;code&gt;REQ&lt;/code&gt;、&lt;code&gt;TOUCH&lt;/code&gt;来回复对消息的处理结果。&lt;/p&gt;

&lt;p&gt;关于TCP protocol相关的内容，在后续博文分析。以下只分析与Channel相关的部分。&lt;/p&gt;

&lt;h1 id=&#34;消息投送结果处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息投送结果处理&lt;/h1&gt;

&lt;h2 id=&#34;消息投送成功的处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息投送成功的处理&lt;/h2&gt;

&lt;p&gt;消费者发送&lt;code&gt;FIN&lt;/code&gt;，表明消息已经被接收并正确处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// FinishMessage successfully discards an in-flight message
func (c *Channel) FinishMessage(clientID int64, id MessageID) error {
	msg, err := c.popInFlightMessage(clientID, id)
	if err != nil {
		return err
	}
	c.removeFromInFlightPQ(msg)
	if c.e2eProcessingLatencyStream != nil {
		c.e2eProcessingLatencyStream.Insert(msg.Timestamp)
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FIN消息在与Channel相关的部分交由&lt;code&gt;FinishMessage&lt;/code&gt;处理。
最后调用&lt;code&gt;addToInFlightPQ&lt;/code&gt;将消息放入&lt;code&gt;inFlightPQ&lt;/code&gt;队列中。
&lt;code&gt;FinishMessage&lt;/code&gt;分别调用&lt;code&gt;popInFlightMessage&lt;/code&gt;和&lt;code&gt;removeFromInFlightPQ&lt;/code&gt;将消息从&lt;code&gt;inFlightMessages&lt;/code&gt;和&lt;code&gt;inFlightPQ&lt;/code&gt;中删除。
最后，统计该消息的投递情况。&lt;/p&gt;

&lt;h2 id=&#34;消息投送失败的处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息投送失败的处理&lt;/h2&gt;

&lt;p&gt;客户端发送&lt;code&gt;REQ&lt;/code&gt;，表明消息投递失败，需要再次被投递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RequeueMessage requeues a message based on `time.Duration`, ie:
//
// `timeoutMs` == 0 - requeue a message immediately
// `timeoutMs`  &amp;gt; 0 - asynchronously wait for the specified timeout
//     and requeue a message (aka &amp;quot;deferred requeue&amp;quot;)
//
func (c *Channel) RequeueMessage(clientID int64, id MessageID, timeout time.Duration) error {
	// remove from inflight first
	msg, err := c.popInFlightMessage(clientID, id)
	if err != nil {
		return err
	}
	c.removeFromInFlightPQ(msg)

	if timeout == 0 {
		return c.doRequeue(msg)
	}

	// deferred requeue
	return c.StartDeferredTimeout(msg, timeout)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel在&lt;code&gt;RequeueMessage&lt;/code&gt;函数对消息投递失败进行处理。该函数将消息从&lt;code&gt;inFlightMessages&lt;/code&gt;和&lt;code&gt;inFlightPQ&lt;/code&gt;中删除，
随后进行重新投递。&lt;/p&gt;

&lt;p&gt;发送&lt;code&gt;REQ&lt;/code&gt;时有一个附加参数timeout，该值为0时表示立即重新投递，大于0时表示等待timeout时间之后投递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// doRequeue performs the low level operations to requeue a message
func (c *Channel) doRequeue(m *Message) error {
	c.RLock()
	defer c.RUnlock()
	if atomic.LoadInt32(&amp;amp;c.exitFlag) == 1 {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}
	err := c.put(m)
	if err != nil {
		return err
	}
	atomic.AddUint64(&amp;amp;c.requeueCount, 1)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立即投递使用&lt;code&gt;doRequeue&lt;/code&gt;函数，该函数简单地调用&lt;code&gt;put&lt;/code&gt;函数重新进行消息的投递，并自增&lt;code&gt;requeueCount&lt;/code&gt;，该变量在统计消息投递情况时用到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) StartDeferredTimeout(msg *Message, timeout time.Duration) error {
	absTs := time.Now().Add(timeout).UnixNano()
	item := &amp;amp;pqueue.Item{Value: msg, Priority: absTs}
	err := c.pushDeferredMessage(item)
	if err != nil {
		return err
	}
	c.addToDeferredPQ(item)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果timeout大于0，则调用&lt;code&gt;StartDeferredTimeout&lt;/code&gt;进行延迟投递。
首先计算延迟投递的时间点，然后调用&lt;code&gt;pushDeferredMessage&lt;/code&gt;将消息加入&lt;code&gt;deferredMessage&lt;/code&gt;字典，
最后将消息放入&lt;code&gt;deferredPQ&lt;/code&gt;队列。延迟投递的消息会被专门的worker扫描并在延迟投递的时间点后进行投递。
需要注意的是，立即重新投递的消息不会进入&lt;code&gt;deferredPQ&lt;/code&gt;队列。&lt;/p&gt;

&lt;h2 id=&#34;消息的超时值的重置:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息的超时值的重置&lt;/h2&gt;

&lt;p&gt;消费者发送&lt;code&gt;TOUCH&lt;/code&gt;，表明该消息的超时值需要被重置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// TouchMessage resets the timeout for an in-flight message
func (c *Channel) TouchMessage(clientID int64, id MessageID, clientMsgTimeout time.Duration) error {
	msg, err := c.popInFlightMessage(clientID, id)
	if err != nil {
		return err
	}
	c.removeFromInFlightPQ(msg)

	newTimeout := time.Now().Add(clientMsgTimeout)
	if newTimeout.Sub(msg.deliveryTS) &amp;gt;=
		c.ctx.nsqd.getOpts().MaxMsgTimeout {
		// we would have gone over, set to the max
		newTimeout = msg.deliveryTS.Add(c.ctx.nsqd.getOpts().MaxMsgTimeout)
	}

	msg.pri = newTimeout.UnixNano()
	err = c.pushInFlightMessage(msg)
	if err != nil {
		return err
	}
	c.addToInFlightPQ(msg)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个过程比较简单，从&lt;code&gt;inFlightPQ&lt;/code&gt;中取出消息，设置新的超时值后重新放入队列，新的超时值由当前时间、
客户端通过&lt;code&gt;IDENTIFY&lt;/code&gt;设置的超时值、配置中允许的最大超时值&lt;code&gt;MaxMsgTimeout&lt;/code&gt;共同决定。&lt;/p&gt;

&lt;h1 id=&#34;消息的超时和延迟投递:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息的超时和延迟投递&lt;/h1&gt;

&lt;p&gt;消息超时和延迟投递的处理流程层次比较多：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;n.waitGroup.Wrap(func() { n.queueScanLoop() })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是在&lt;code&gt;nsqd\nsqd.go&lt;/code&gt;中启动的处理延迟消息的goroutine。该goroutine执行&lt;code&gt;queueScanLoop&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// queueScanLoop runs in a single goroutine to process in-flight and deferred
// priority queues. It manages a pool of queueScanWorker (configurable max of
// QueueScanWorkerPoolMax (default: 4)) that process channels concurrently.
//
// It copies Redis&#39;s probabilistic expiration algorithm: it wakes up every
// QueueScanInterval (default: 100ms) to select a random QueueScanSelectionCount
// (default: 20) channels from a locally cached list (refreshed every
// QueueScanRefreshInterval (default: 5s)).
//
// If either of the queues had work to do the channel is considered &amp;quot;dirty&amp;quot;.
//
// If QueueScanDirtyPercent (default: 25%) of the selected channels were dirty,
// the loop continues without sleep.
func (n *NSQD) queueScanLoop() {
	workCh := make(chan *Channel, n.getOpts().QueueScanSelectionCount)
	responseCh := make(chan bool, n.getOpts().QueueScanSelectionCount)
	closeCh := make(chan int)

	workTicker := time.NewTicker(n.getOpts().QueueScanInterval)
	refreshTicker := time.NewTicker(n.getOpts().QueueScanRefreshInterval)

	channels := n.channels()
	n.resizePool(len(channels), workCh, responseCh, closeCh)

	for {
		select {
		case &amp;lt;-workTicker.C:
			if len(channels) == 0 {
				continue
			}
		case &amp;lt;-refreshTicker.C:
			channels = n.channels()
			n.resizePool(len(channels), workCh, responseCh, closeCh)
			continue
		case &amp;lt;-n.exitChan:
			goto exit
		}

		num := n.getOpts().QueueScanSelectionCount
		if num &amp;gt; len(channels) {
			num = len(channels)
		}

	loop:
		for _, i := range util.UniqRands(num, len(channels)) {
			workCh &amp;lt;- channels[i]
		}

		numDirty := 0
		for i := 0; i &amp;lt; num; i++ {
			if &amp;lt;-responseCh {
				numDirty++
			}
		}

		if float64(numDirty)/float64(num) &amp;gt; n.getOpts().QueueScanDirtyPercent {
			goto loop
		}
	}

exit:
	n.logf(&amp;quot;QUEUESCAN: closing&amp;quot;)
	close(closeCh)
	workTicker.Stop()
	refreshTicker.Stop()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数使用若干个worker来扫描并处理当前在投递中以及等待重新投递的消息。worker的个数由配置和当前Channel数量共同决定。
首先，初始化3个gochannel：workCh、responseCh、closeCh，分别控制worker的输入、输出和销毁。&lt;/p&gt;

&lt;p&gt;然后获取当前的Channel集合，并且调用&lt;code&gt;resizePool&lt;/code&gt;函数来启动指定数量的worker。&lt;/p&gt;

&lt;p&gt;最后进入扫描的循环。在循环中，等待两个定时器，&lt;code&gt;workTicker&lt;/code&gt;和&lt;code&gt;refreshTicker&lt;/code&gt;，
定时时间分别由由配置中的&lt;code&gt;QueueScanInterval&lt;/code&gt;和&lt;code&gt;QueueScanRefreshInterval&lt;/code&gt;决定。
这种由等待定时器触发的循环避免了函数持续的执行影响性能，而Golang的特性使得这种机制在写法上非常简洁。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;workTicker&lt;/code&gt;定时器触发扫描流程。
nsqd采用了Redis的probabilistic expiration算法来进行扫描。首先从所有Channel中随机选取部分Channel，然后遍历被选取的Channel，投到&lt;code&gt;workerChan&lt;/code&gt;中，并且等待反馈结果，
结果有两种，dirty和非dirty，如果dirty的比例超过配置中设定的&lt;code&gt;QueueScanDirtyPercent&lt;/code&gt;，那么不进入休眠，
继续扫描，如果比例较低，则重新等待定时器触发下一轮扫描。这种机制可以在保证处理延时较低的情况下减少对CPU资源的浪费。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refreshTicker&lt;/code&gt;定时器触发更新Channel列表流程。
这个流程比较简单，先获取一次Channel列表，
再调用&lt;code&gt;resizePool&lt;/code&gt;重新分配worker。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来再看看&lt;code&gt;resizePool&lt;/code&gt;的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// resizePool adjusts the size of the pool of queueScanWorker goroutines
//
// 	1 &amp;lt;= pool &amp;lt;= min(num * 0.25, QueueScanWorkerPoolMax)
//
func (n *NSQD) resizePool(num int, workCh chan *Channel, responseCh chan bool, closeCh chan int) {
	idealPoolSize := int(float64(num) * 0.25)
	if idealPoolSize &amp;lt; 1 {
		idealPoolSize = 1
	} else if idealPoolSize &amp;gt; n.getOpts().QueueScanWorkerPoolMax {
		idealPoolSize = n.getOpts().QueueScanWorkerPoolMax
	}
	for {
		if idealPoolSize == n.poolSize {
			break
		} else if idealPoolSize &amp;lt; n.poolSize {
			// contract
			closeCh &amp;lt;- 1
			n.poolSize--
		} else {
			// expand
			n.waitGroup.Wrap(func() {
				n.queueScanWorker(workCh, responseCh, closeCh)
			})
			n.poolSize++
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个部分比较简单。注意一点，当需要的worker数量超过之前分配的数量时，通过向&lt;code&gt;closeCh&lt;/code&gt;投递消息使多余的worker销毁，
如果需要的数量比之前的多，则通过&lt;code&gt;queueScanWorker&lt;/code&gt;创建新的worker。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// queueScanWorker receives work (in the form of a channel) from queueScanLoop
// and processes the deferred and in-flight queues
func (n *NSQD) queueScanWorker(workCh chan *Channel, responseCh chan bool, closeCh chan int) {
	for {
		select {
		case c := &amp;lt;-workCh:
			now := time.Now().UnixNano()
			dirty := false
			if c.processInFlightQueue(now) {
				dirty = true
			}
			if c.processDeferredQueue(now) {
				dirty = true
			}
			responseCh &amp;lt;- dirty
		case &amp;lt;-closeCh:
			return
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;queueScanWorker&lt;/code&gt;接收&lt;code&gt;workCh&lt;/code&gt;发来的消息，处理，并且通过&lt;code&gt;responseCh&lt;/code&gt;反馈消息。收到&lt;code&gt;closeCh&lt;/code&gt;时则关闭。
由于所有worker都监听相同的&lt;code&gt;closeCh&lt;/code&gt;，所以当向&lt;code&gt;closeCh&lt;/code&gt;发送消息时，随机关闭一个worker。
且由于&lt;code&gt;workCh&lt;/code&gt;和&lt;code&gt;closeCh&lt;/code&gt;的监听是串行的，所以不存在任务处理到一半时被关闭的可能。
这也是nsq中优雅关闭gochannel的的一个例子。&lt;/p&gt;

&lt;p&gt;worker处理两件事：&lt;/p&gt;

&lt;p&gt;一是处理inFlight消息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func (c *Channel) processInFlightQueue(t int64) bool {
	c.exitMutex.RLock()
	defer c.exitMutex.RUnlock()

	if c.Exiting() {
		return false
	}

	dirty := false
	for {
		c.inFlightMutex.Lock()
		msg, _ := c.inFlightPQ.PeekAndShift(t)
		c.inFlightMutex.Unlock()

		if msg == nil {
			goto exit
		}
		dirty = true

		_, err := c.popInFlightMessage(msg.clientID, msg.ID)
		if err != nil {
			goto exit
		}
		atomic.AddUint64(&amp;amp;c.timeoutCount, 1)
		c.RLock()
		client, ok := c.clients[msg.clientID]
		c.RUnlock()
		if ok {
			client.TimedOutMessage()
		}
		c.doRequeue(msg)
	}

exit:
	return dirty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;processInFlightQueue&lt;/code&gt;取出&lt;code&gt;inFlightPQ&lt;/code&gt;顶部的消息，如果当前消息已经超时，则将消息从队列中移除，并返回消息。
由于队列是优先级队列，所以如果&lt;code&gt;processInFlightQueue&lt;/code&gt;取出的消息为空，则不需要再往后取了，直接返回false表示当前非dirty状态。
如果取到了消息，则说明该消息投递超时，需要把消息传入&lt;code&gt;doRequeue&lt;/code&gt;立即重新投递。&lt;/p&gt;

&lt;p&gt;二是处理deferred消息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func (c *Channel) processDeferredQueue(t int64) bool {
	c.exitMutex.RLock()
	defer c.exitMutex.RUnlock()

	if c.Exiting() {
		return false
	}

	dirty := false
	for {
		c.deferredMutex.Lock()
		item, _ := c.deferredPQ.PeekAndShift(t)
		c.deferredMutex.Unlock()

		if item == nil {
			goto exit
		}
		dirty = true

		msg := item.Value.(*Message)
		_, err := c.popDeferredMessage(msg.ID)
		if err != nil {
			goto exit
		}
		c.doRequeue(msg)
	}

exit:
	return dirty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该处理流程与处理inFlight基本相同，不再详述。&lt;/p&gt;

&lt;h1 id=&#34;其他操作:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;其他操作&lt;/h1&gt;

&lt;p&gt;Channel中还有些其他函数如
&lt;code&gt;Exiting&lt;/code&gt;、&lt;code&gt;Delete&lt;/code&gt;、&lt;code&gt;Close&lt;/code&gt;、&lt;code&gt;exit&lt;/code&gt;、&lt;code&gt;Empty&lt;/code&gt;、&lt;code&gt;flush&lt;/code&gt;、&lt;code&gt;Pause&lt;/code&gt;、&lt;code&gt;UnPause&lt;/code&gt;、&lt;code&gt;doPause&lt;/code&gt;
等与Topic中很接近，不再详述。&lt;code&gt;AddClient&lt;/code&gt;和&lt;code&gt;RemoveClient&lt;/code&gt;将在分析Client时讨论。&lt;/p&gt;

&lt;h1 id=&#34;总结:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;Topic/Channel是发布/订阅模型的一种实现。Topic对应于发布，Channel对应于订阅。
消费者通过在Topic下生成不同的Channel来接收来自该Topic的消息。
通过生成相同的Channel来实现消费者负载均衡。&lt;/p&gt;

&lt;p&gt;Channel本身在投递消息给消费者时维护两个队列，一个是inFlight队列，该队列存储正在投递，但还没被标记为投递成功的消息。
另一个是deferred队列，用来存储需要被延时投递的消息。&lt;/p&gt;

&lt;p&gt;inFlight队列中消息可能因为投递超时而失败，deferred队列中的消息需要在到达指定时间后进行重新投递。
如果为两个队列中的每个消息都分别指定定时器，无疑是非常消耗资源的。因此nsq采用定时扫描队列的做法。
在扫描时采用多个worker分别处理。这种类似多线程的处理方式提高了处理效率。
nsq在扫描策略上使用了Redis的probabilistic expiration算法，同时动态调整worker的数量，
这些优化平衡了效率和资源占用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 26: Remove Duplicates from Sorted Array</title>
      <link>http://blog.rayxxzhang.com/2016/02/28/leetcode_26/</link>
      <pubDate>Sun, 28 Feb 2016 20:53:12 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2016/02/28/leetcode_26/</guid>
      <description>

&lt;h1 id=&#34;题目:faeb78a3cbe3cf31c336af8064184bc2&#34;&gt;题目&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;

&lt;p&gt;For example,
Given input array nums = &lt;code&gt;[1,1,2]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;Your function should return length = &lt;code&gt;2&lt;/code&gt;, with the first two elements of nums being &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; respectively. It doesn&amp;rsquo;t matter what you leave beyond the new length.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;解题思路:faeb78a3cbe3cf31c336af8064184bc2&#34;&gt;解题思路&lt;/h1&gt;

&lt;p&gt;这道题是一道简单题，通过比较容易，但是不同解法还是存在着一些效率差别的。&lt;/p&gt;

&lt;h2 id=&#34;解法一:faeb78a3cbe3cf31c336af8064184bc2&#34;&gt;解法一&lt;/h2&gt;

&lt;p&gt;解法一判断在相邻的两个数相等的情况下，后面的所有数字往前移位，虽然能通过，但是效率较低，时间复杂度O(n^2)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        int unique = len;
        for(int i = 0; i &amp;lt; unique - 1;) {
            if(nums[i] == nums[i + 1]) {
                for(int j = i + 1; j &amp;lt; unique; ++j) {
                    nums[j - 1] = nums[j];
                }
                --unique;
            } else {
                ++i;
            }
        }
        return unique;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解法二:faeb78a3cbe3cf31c336af8064184bc2&#34;&gt;解法二&lt;/h2&gt;

&lt;p&gt;解法二将重复的数字填充成&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，然后再最后对数组进行排序即可，解法二使用最后的排序代替了遍历中的不断移位
时间复杂度O(nlogn)，优于解法一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        int unique = len;
        for(int i = 0; i &amp;lt; len - 1; ++i) {
            if(nums[i] == nums[i + 1]) {
                nums[i] = Integer.MAX_VALUE;
                --unique;
            }
        }
        Arrays.sort(nums);
        return unique;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;解法三:faeb78a3cbe3cf31c336af8064184bc2&#34;&gt;解法三&lt;/h2&gt;

&lt;p&gt;解法三使用了两个游标，分别指向当前不重复的尾部和要进行比较的头部，当两者不同时，将比较的头部的数复制到当前不重复的尾部的后一个位置，
该解法只需要一次遍历，无需而外的排序，时间复杂度O(n)，是最优解法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        int i = 0;
        for(int j = 1; j &amp;lt; len; ++j) {
            if(nums[i] != nums[j]) {
                ++i;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>nsq源码阅读笔记之nsqd（三）——diskQueue</title>
      <link>http://blog.rayxxzhang.com/2015/11/27/nsqd_source_3_diskqueue/</link>
      <pubDate>Fri, 27 Nov 2015 16:14:26 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/11/27/nsqd_source_3_diskqueue/</guid>
      <description>

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;是&lt;code&gt;backendQueue&lt;/code&gt;接口的一个实现。&lt;code&gt;backendQueue&lt;/code&gt;的作用是在实现在内存go channel缓冲区满的情况下对消息的处理的对象。
除了&lt;code&gt;diskQueue&lt;/code&gt;外还有&lt;code&gt;dummyBackendQueue&lt;/code&gt;实现了&lt;code&gt;backendQueue&lt;/code&gt;接口。&lt;/p&gt;

&lt;p&gt;对于临时（#ephemeral结尾）Topic/Channel，在创建时会使用&lt;code&gt;dummyBackendQueue&lt;/code&gt;初始化&lt;code&gt;backend&lt;/code&gt;，
&lt;code&gt;dummyBackendQueue&lt;/code&gt;只是为了统一临时和非临时Topic/Channel而写的，它只是实现了接口，不做任何实质上的操作，
因此在内存缓冲区满时直接丢弃消息。这也是临时Topic/Channel和非临时的一个比较大的差别。
每个非临时Topic/Channel，创建的时候使用&lt;code&gt;diskQueue&lt;/code&gt;初始化&lt;code&gt;backend&lt;/code&gt;，&lt;code&gt;diskQueue&lt;/code&gt;的功能是将消息写入磁盘进行持久化，
并在需要时从中取出消息重新向客户端投递。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;的实现在&lt;code&gt;nsqd/disk_queue.go&lt;/code&gt;中。&lt;strong&gt;需要注意一点&lt;/strong&gt;，查找&lt;code&gt;diskQueue&lt;/code&gt;中的函数的调用可能不会返回正确的结果，
因为&lt;code&gt;diskQueue&lt;/code&gt;对外是以&lt;code&gt;backendQueue&lt;/code&gt;形式存在，因此查找&lt;code&gt;diskQueue&lt;/code&gt;的函数的调用情况时应当查找&lt;code&gt;backendQueue&lt;/code&gt;中相应函数的调用。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-的创建和初始化:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的创建和初始化&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// newDiskQueue instantiates a new instance of diskQueue, retrieving metadata
// from the filesystem and starting the read ahead goroutine
func newDiskQueue(name string, dataPath string, maxBytesPerFile int64,
	minMsgSize int32, maxMsgSize int32,
	syncEvery int64, syncTimeout time.Duration,
	logger logger) BackendQueue {
	d := diskQueue{
		name:              name,
		dataPath:          dataPath,
		maxBytesPerFile:   maxBytesPerFile,
		minMsgSize:        minMsgSize,
		maxMsgSize:        maxMsgSize,
		readChan:          make(chan []byte),
		writeChan:         make(chan []byte),
		writeResponseChan: make(chan error),
		emptyChan:         make(chan int),
		emptyResponseChan: make(chan error),
		exitChan:          make(chan int),
		exitSyncChan:      make(chan int),
		syncEvery:         syncEvery,
		syncTimeout:       syncTimeout,
		logger:            logger,
	}

	// no need to lock here, nothing else could possibly be touching this instance
	err := d.retrieveMetaData()
	if err != nil &amp;amp;&amp;amp; !os.IsNotExist(err) {
		d.logf(&amp;quot;ERROR: diskqueue(%s) failed to retrieveMetaData - %s&amp;quot;, d.name, err)
	}

	go d.ioLoop()

	return &amp;amp;d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;的获得是通过&lt;code&gt;newDiskQueue&lt;/code&gt;，该函数比较简单，通过传入的参数创建一个&lt;code&gt;dispQueue&lt;/code&gt;，
然后通过&lt;code&gt;retrieveMetaData&lt;/code&gt;函数获取之前与该&lt;code&gt;diskQueue&lt;/code&gt;相关联的Topic/Channel已经持久化的信息。最后启动&lt;code&gt;ioLoop&lt;/code&gt;循环处理消息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// retrieveMetaData initializes state from the filesystem
func (d *diskQueue) retrieveMetaData() error {
	var f *os.File
	var err error

	fileName := d.metaDataFileName()
	f, err = os.OpenFile(fileName, os.O_RDONLY, 0600)
	if err != nil {
		return err
	}
	defer f.Close()

	var depth int64
	_, err = fmt.Fscanf(f, &amp;quot;%d\n%d,%d\n%d,%d\n&amp;quot;,
		&amp;amp;depth,
		&amp;amp;d.readFileNum, &amp;amp;d.readPos,
		&amp;amp;d.writeFileNum, &amp;amp;d.writePos)
	if err != nil {
		return err
	}
	atomic.StoreInt64(&amp;amp;d.depth, depth)
	d.nextReadFileNum = d.readFileNum
	d.nextReadPos = d.readPos

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;retrieveMetaData&lt;/code&gt;函数从磁盘中恢复&lt;code&gt;diskQueue&lt;/code&gt;的状态。&lt;code&gt;diskQueue&lt;/code&gt;会定时将自己的状态备份到文件中，
文件名由&lt;code&gt;metaDataFileName&lt;/code&gt;函数确定。&lt;code&gt;retrieveMetaData&lt;/code&gt;函数同样通过&lt;code&gt;metaDataFileName&lt;/code&gt;函数获得保存状态的文件名并打开。
该文件只有三行，格式为&lt;code&gt;%d\n%d,%d\n%d,%d\n&lt;/code&gt;，第一行保存着该&lt;code&gt;diskQueue&lt;/code&gt;中消息的数量（&lt;code&gt;depth&lt;/code&gt;），
第二行保存&lt;code&gt;readFileNum&lt;/code&gt;和&lt;code&gt;readPos&lt;/code&gt;，第三行保存&lt;code&gt;writeFileNum&lt;/code&gt;和&lt;code&gt;writePos&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里不太理解的一个地方是&lt;code&gt;d.depth&lt;/code&gt;通过一个临时变量去获取然后通过&lt;code&gt;atomic.StoreInt64&lt;/code&gt;保存。个人觉得没有必要这么做。
当然作者在&lt;a href=&#34;https://github.com/nsqio/nsq/pull/203#discussion-diff-4280536&#34;&gt;nsqd: diskqueue corruption and depth accounting&lt;/a&gt;这个Pull Request中也提到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I dont believe that this should be strictly necessary because &lt;code&gt;retrieveMetaData&lt;/code&gt; is only ever called in &lt;code&gt;NewDiskQueue&lt;/code&gt; and the &lt;code&gt;ioLoop&lt;/code&gt; goroutine is launched after that call (which according to the go memory model is safe).&lt;/p&gt;

&lt;p&gt;However, I&amp;rsquo;m not 100% sure about interactions between the go memory model, go-routines, and the combined use of atomic and non-atomic operations (which is what this was relying on before this change&amp;hellip; i.e. this was the only mutation of &lt;code&gt;d.depth&lt;/code&gt; that was &lt;strong&gt;not&lt;/strong&gt; using atomic ops).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，这只是个比较保险的做法，并不一定意味着直接保存到&lt;code&gt;d.depth&lt;/code&gt;就不安全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// persistMetaData atomically writes state to the filesystem
func (d *diskQueue) persistMetaData() error {
	var f *os.File
	var err error

	fileName := d.metaDataFileName()
	tmpFileName := fmt.Sprintf(&amp;quot;%s.%d.tmp&amp;quot;, fileName, rand.Int())

	// write to tmp file
	f, err = os.OpenFile(tmpFileName, os.O_RDWR|os.O_CREATE, 0600)
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(f, &amp;quot;%d\n%d,%d\n%d,%d\n&amp;quot;,
		atomic.LoadInt64(&amp;amp;d.depth),
		d.readFileNum, d.readPos,
		d.writeFileNum, d.writePos)
	if err != nil {
		f.Close()
		return err
	}
	f.Sync()
	f.Close()

	// atomically rename
	return atomicRename(tmpFileName, fileName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;retrieveMetaData&lt;/code&gt;相对应的是&lt;code&gt;persistMetaData&lt;/code&gt;函数，这个函数将运行时的元数据保存到文件用于下次重新构建&lt;code&gt;diskQueue&lt;/code&gt;时的恢复。
逻辑基本与&lt;code&gt;retrieveMetaData&lt;/code&gt;，此处不再赘述。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-的消息循环:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的消息循环&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ioLoop provides the backend for exposing a go channel (via ReadChan())
// in support of multiple concurrent queue consumers
//
// it works by looping and branching based on whether or not the queue has data
// to read and blocking until data is either read or written over the appropriate
// go channels
//
// conveniently this also means that we&#39;re asynchronously reading from the filesystem
func (d *diskQueue) ioLoop() {
	var dataRead []byte
	var err error
	var count int64
	var r chan []byte

	syncTicker := time.NewTicker(d.syncTimeout)

	for {
		// dont sync all the time :)
		if count == d.syncEvery {
			count = 0
			d.needSync = true
		}

		if d.needSync {
			err = d.sync()
			if err != nil {
				d.logf(&amp;quot;ERROR: diskqueue(%s) failed to sync - %s&amp;quot;, d.name, err)
			}
		}

		if (d.readFileNum &amp;lt; d.writeFileNum) || (d.readPos &amp;lt; d.writePos) {
			if d.nextReadPos == d.readPos {
				dataRead, err = d.readOne()
				if err != nil {
					d.logf(&amp;quot;ERROR: reading from diskqueue(%s) at %d of %s - %s&amp;quot;,
						d.name, d.readPos, d.fileName(d.readFileNum), err)
					d.handleReadError()
					continue
				}
			}
			r = d.readChan
		} else {
			r = nil
		}

		select {
		// the Go channel spec dictates that nil channel operations (read or write)
		// in a select are skipped, we set r to d.readChan only when there is data to read
		case r &amp;lt;- dataRead:
			// moveForward sets needSync flag if a file is removed
			d.moveForward()
		case &amp;lt;-d.emptyChan:
			d.emptyResponseChan &amp;lt;- d.deleteAllFiles()
			count = 0
		case dataWrite := &amp;lt;-d.writeChan:
			count++
			d.writeResponseChan &amp;lt;- d.writeOne(dataWrite)
		case &amp;lt;-syncTicker.C:
			if count &amp;gt; 0 {
				count = 0
				d.needSync = true
			}
		case &amp;lt;-d.exitChan:
			goto exit
		}
	}

exit:
	d.logf(&amp;quot;DISKQUEUE(%s): closing ... ioLoop&amp;quot;, d.name)
	syncTicker.Stop()
	d.exitSyncChan &amp;lt;- 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ioLoop&lt;/code&gt;函数实现了&lt;code&gt;diskQueue&lt;/code&gt;的消息循环，&lt;code&gt;diskQueue&lt;/code&gt;的定时操作和读写操作的核心都在这个函数中完成。&lt;/p&gt;

&lt;p&gt;函数首先使用&lt;code&gt;time.NewTicker(d.syncTimeout)&lt;/code&gt;定义了&lt;code&gt;syncTicker&lt;/code&gt;变量，&lt;code&gt;syncTicker&lt;/code&gt;的类型是&lt;code&gt;time.Ticker&lt;/code&gt;，
每隔&lt;code&gt;d.syncTimeout&lt;/code&gt;时间就会在&lt;code&gt;syncTicker.C&lt;/code&gt;这个go channel产生一个消息。
通过select &lt;code&gt;syncTicker.C&lt;/code&gt;能实现至多&lt;code&gt;d.syncTimeout&lt;/code&gt;时间就跳出select块一次，这种方式相当于一个延时的&lt;code&gt;default&lt;/code&gt;子句。
在&lt;code&gt;ioLoop&lt;/code&gt;中，通过这种方式，就能在一个goroutine中既实现消息的接收又实现定时任务（跳出select后执行定时任务，然后在进入select）。
有点类似于定时的轮询。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ioLoop&lt;/code&gt;的定时任务是调用&lt;code&gt;sync&lt;/code&gt;函数刷新文件，防止突然结束程序后内存中的内容未被提交到磁盘，导致内容丢失。
控制是否需要同步的变量是&lt;code&gt;d.needSync&lt;/code&gt;，该变量在一次&lt;code&gt;sync&lt;/code&gt;后会被置为&lt;code&gt;false&lt;/code&gt;，在许多需要刷新文件的地方会被置为&lt;code&gt;true&lt;/code&gt;。
在&lt;code&gt;ioLoop&lt;/code&gt;中，&lt;code&gt;d.needSync&lt;/code&gt;变量还跟刷新计数器&lt;code&gt;count&lt;/code&gt;变量有关，&lt;code&gt;count&lt;/code&gt;值的变化规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一次消息循环中，有写入操作，那么&lt;code&gt;count&lt;/code&gt;就会被自增。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;count&lt;/code&gt;达到&lt;code&gt;d.syncEvery&lt;/code&gt;时，会将&lt;code&gt;count&lt;/code&gt;重置为0并且将&lt;code&gt;d.needSync&lt;/code&gt;置为&lt;code&gt;true&lt;/code&gt;，随后进行文件的刷新。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;emptyChan&lt;/code&gt;收到消息时，&lt;code&gt;count&lt;/code&gt;会被重置为0，因为文件已经被删除了，所有要重置刷新计数器。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;syncTicker.C&lt;/code&gt;收到消息后，会将&lt;code&gt;count&lt;/code&gt;重置为0，并且将&lt;code&gt;d.needSync&lt;/code&gt;置为&lt;code&gt;true&lt;/code&gt;。也就是至多&lt;code&gt;d.syncTimeout&lt;/code&gt;时间刷新一次文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;ioLoop&lt;/code&gt;还定时检测当前是否有数据需要被读取，如果&lt;code&gt;(d.readFileNum &amp;lt; d.writeFileNum) || (d.readPos &amp;lt; d.writePos)&lt;/code&gt;
和`&lt;code&gt;d.nextReadPos == d.readPos&lt;/code&gt;这两个条件成立，则执行&lt;code&gt;d.readOne()&lt;/code&gt;并将结果放入&lt;code&gt;dataRead&lt;/code&gt;中，然后设置&lt;code&gt;r&lt;/code&gt;为&lt;code&gt;d.readChan&lt;/code&gt;。
如果条件不成立，则将&lt;code&gt;r&lt;/code&gt;置为空值&lt;code&gt;nil&lt;/code&gt;。随后的select语句中有&lt;code&gt;case r &amp;lt;- dataRead:&lt;/code&gt;这样一个分支，在注释中作者写了这是一个Golang的特性，
即：如果&lt;code&gt;r&lt;/code&gt;不为空，则会将&lt;code&gt;dataRead&lt;/code&gt;送入go channel。进入&lt;code&gt;d.readChan&lt;/code&gt;的消息通过&lt;code&gt;ReadChan&lt;/code&gt;函数向外暴露，最终被Topic/Channel的消息循环读取。
而如果&lt;code&gt;r&lt;/code&gt;为空，则这个分支会被跳过。这个特性的使用统一了select的逻辑，简化了当数据为空时的判断。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-的写操作:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的写操作&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Put writes a []byte to the queue
func (d *diskQueue) Put(data []byte) error {
	d.RLock()
	defer d.RUnlock()

	if d.exitFlag == 1 {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}

	d.writeChan &amp;lt;- data
	return &amp;lt;-d.writeResponseChan
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写操作的对外接口是&lt;code&gt;Put&lt;/code&gt;函数，该函数比较简单，加锁，并且将数据放入&lt;code&gt;d.writeChan&lt;/code&gt;，等待&lt;code&gt;d.writeResponseChan&lt;/code&gt;的结果后返回。
&lt;code&gt;d.writeChan&lt;/code&gt;的接收在&lt;code&gt;ioLoop&lt;/code&gt;中select的一个分支，处理时调用&lt;code&gt;writeOne&lt;/code&gt;函数，并将处理结果放入&lt;code&gt;d.writeResponseChan&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// writeOne performs a low level filesystem write for a single []byte
// while advancing write positions and rolling files, if necessary
func (d *diskQueue) writeOne(data []byte) error {
	var err error

	if d.writeFile == nil {
		curFileName := d.fileName(d.writeFileNum)
		d.writeFile, err = os.OpenFile(curFileName, os.O_RDWR|os.O_CREATE, 0600)
		if err != nil {
			return err
		}

		d.logf(&amp;quot;DISKQUEUE(%s): writeOne() opened %s&amp;quot;, d.name, curFileName)

		if d.writePos &amp;gt; 0 {
			_, err = d.writeFile.Seek(d.writePos, 0)
			if err != nil {
				d.writeFile.Close()
				d.writeFile = nil
				return err
			}
		}
	}

	dataLen := int32(len(data))

	if dataLen &amp;lt; d.minMsgSize || dataLen &amp;gt; d.maxMsgSize {
		return fmt.Errorf(&amp;quot;invalid message write size (%d) maxMsgSize=%d&amp;quot;, dataLen, d.maxMsgSize)
	}

	d.writeBuf.Reset()
	err = binary.Write(&amp;amp;d.writeBuf, binary.BigEndian, dataLen)
	if err != nil {
		return err
	}

	_, err = d.writeBuf.Write(data)
	if err != nil {
		return err
	}

	// only write to the file once
	_, err = d.writeFile.Write(d.writeBuf.Bytes())
	if err != nil {
		d.writeFile.Close()
		d.writeFile = nil
		return err
	}

	totalBytes := int64(4 + dataLen)
	d.writePos += totalBytes
	atomic.AddInt64(&amp;amp;d.depth, 1)

	if d.writePos &amp;gt; d.maxBytesPerFile {
		d.writeFileNum++
		d.writePos = 0

		// sync every time we start writing to a new file
		err = d.sync()
		if err != nil {
			d.logf(&amp;quot;ERROR: diskqueue(%s) failed to sync - %s&amp;quot;, d.name, err)
		}

		if d.writeFile != nil {
			d.writeFile.Close()
			d.writeFile = nil
		}
	}

	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;writeOne&lt;/code&gt;函数是写操作的最终执行部分，负责将消息写入磁盘。函数逻辑比较简单。消息写入步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;若当前要写的文件不存在，则通过&lt;code&gt;d.fileName(d.writeFileNum)&lt;/code&gt;获得文件名，并创建文件&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;d.writePos&lt;/code&gt;定位本次写的位置&lt;/li&gt;
&lt;li&gt;从要写入的内容得到要写入的长度&lt;/li&gt;
&lt;li&gt;先写入3中计算出的消息长度（4字节），然后写入消息本身&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;d.writePos&lt;/code&gt;后移&lt;code&gt;4 + 消息长度&lt;/code&gt;作为下次写入位置。加4是因为消息长度本身也占4字节。&lt;/li&gt;
&lt;li&gt;判断&lt;code&gt;d.writePos&lt;/code&gt;是否大于每个文件的最大字节数&lt;code&gt;d.maxBytesPerFile&lt;/code&gt;，如果是，则将&lt;code&gt;d.writeFileNum&lt;/code&gt;加1，
并重置&lt;code&gt;d.writePos&lt;/code&gt;。这个操作的目的是为了防止单个文件过大。&lt;/li&gt;
&lt;li&gt;如果下次要写入新的文件，那么需要调用&lt;code&gt;sync&lt;/code&gt;函数对当前文件进行同步。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;diskqueue-的读操作:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的读操作&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// readOne performs a low level filesystem read for a single []byte
// while advancing read positions and rolling files, if necessary
func (d *diskQueue) readOne() ([]byte, error) {
	var err error
	var msgSize int32

	if d.readFile == nil {
		curFileName := d.fileName(d.readFileNum)
		d.readFile, err = os.OpenFile(curFileName, os.O_RDONLY, 0600)
		if err != nil {
			return nil, err
		}

		d.logf(&amp;quot;DISKQUEUE(%s): readOne() opened %s&amp;quot;, d.name, curFileName)

		if d.readPos &amp;gt; 0 {
			_, err = d.readFile.Seek(d.readPos, 0)
			if err != nil {
				d.readFile.Close()
				d.readFile = nil
				return nil, err
			}
		}

		d.reader = bufio.NewReader(d.readFile)
	}

	err = binary.Read(d.reader, binary.BigEndian, &amp;amp;msgSize)
	if err != nil {
		d.readFile.Close()
		d.readFile = nil
		return nil, err
	}

	if msgSize &amp;lt; d.minMsgSize || msgSize &amp;gt; d.maxMsgSize {
		// this file is corrupt and we have no reasonable guarantee on
		// where a new message should begin
		d.readFile.Close()
		d.readFile = nil
		return nil, fmt.Errorf(&amp;quot;invalid message read size (%d)&amp;quot;, msgSize)
	}

	readBuf := make([]byte, msgSize)
	_, err = io.ReadFull(d.reader, readBuf)
	if err != nil {
		d.readFile.Close()
		d.readFile = nil
		return nil, err
	}

	totalBytes := int64(4 + msgSize)

	// we only advance next* because we have not yet sent this to consumers
	// (where readFileNum, readPos will actually be advanced)
	d.nextReadPos = d.readPos + totalBytes
	d.nextReadFileNum = d.readFileNum

	// TODO: each data file should embed the maxBytesPerFile
	// as the first 8 bytes (at creation time) ensuring that
	// the value can change without affecting runtime
	if d.nextReadPos &amp;gt; d.maxBytesPerFile {
		if d.readFile != nil {
			d.readFile.Close()
			d.readFile = nil
		}

		d.nextReadFileNum++
		d.nextReadPos = 0
	}

	return readBuf, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消息读取对外暴露的是一个go channel，而数据的最终来源是&lt;code&gt;ioLoop&lt;/code&gt;中调用的&lt;code&gt;readOne&lt;/code&gt;函数。&lt;code&gt;readOne&lt;/code&gt;函数逻辑跟&lt;code&gt;writeOne&lt;/code&gt;类似，
只是把写操作换成了读操作，唯一差异较大的地方是&lt;code&gt;d.nextReadPos&lt;/code&gt;和&lt;code&gt;d.nextReadFileNum&lt;/code&gt;这两个变量的使用。&lt;/p&gt;

&lt;p&gt;在写操作时，如果写入成功，则可以直接将写入位置和写入文件更新。但是对于读操作来说，由于读取的目的是为了向客户端投递，
因此无法保证一定能投递成功。因此需要使用next开头的两个变量来保存成功后需要读的位置，如果投递没有成功，
则继续使用当前的读取位置将再一次尝试将消息投递给客户端。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (d *diskQueue) moveForward() {
	oldReadFileNum := d.readFileNum
	d.readFileNum = d.nextReadFileNum
	d.readPos = d.nextReadPos
	depth := atomic.AddInt64(&amp;amp;d.depth, -1)

	// see if we need to clean up the old file
	if oldReadFileNum != d.nextReadFileNum {
		// sync every time we start reading from a new file
		d.needSync = true

		fn := d.fileName(oldReadFileNum)
		err := os.Remove(fn)
		if err != nil {
			d.logf(&amp;quot;ERROR: failed to Remove(%s) - %s&amp;quot;, fn, err)
		}
	}

	d.checkTailCorruption(depth)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当消息投递成功后，则使用&lt;code&gt;moveForward&lt;/code&gt;函数将保存在&lt;code&gt;d.nextReadPos&lt;/code&gt;和&lt;code&gt;d.nextReadFileNum&lt;/code&gt;中的值取出，
赋值给&lt;code&gt;d.readPos&lt;/code&gt;和&lt;code&gt;d.readFileNum&lt;/code&gt;，&lt;code&gt;moveForward&lt;/code&gt;函数还负责清理已经读完的旧文件。最后，调用&lt;code&gt;checkTailCorruption&lt;/code&gt;函数检查文件是否有错，
如果出现错误，则调用&lt;code&gt;skipToNextRWFile&lt;/code&gt;重置读取和写入的文件编号和位置。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-中的其他函数:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;中的其他函数&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;中还有与错误处理相关的&lt;code&gt;handleReadError&lt;/code&gt;，与关闭&lt;code&gt;diskQueue&lt;/code&gt;相关的&lt;code&gt;Close&lt;/code&gt;，&lt;code&gt;Delete&lt;/code&gt;，&lt;code&gt;exit&lt;/code&gt;，&lt;code&gt;Empty&lt;/code&gt;和&lt;code&gt;deleteAllFiles&lt;/code&gt;等，
函数，逻辑较简单，不再专门分析。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-总结:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;总结&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;主要逻辑是对磁盘的读写操作，较为琐碎但没有复杂的架构。
其中消息循环的思路和读写过程周全的考虑都值得学习的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nsq源码阅读笔记之nsqd（二）——Topic</title>
      <link>http://blog.rayxxzhang.com/2015/11/25/nsqd_source_2_topics/</link>
      <pubDate>Wed, 25 Nov 2015 16:09:44 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/11/25/nsqd_source_2_topics/</guid>
      <description>

&lt;p&gt;与&lt;strong&gt;Topic&lt;/strong&gt;相关的代码主要位于&lt;code&gt;nsqd/nsqd.go&lt;/code&gt;, &lt;code&gt;nsqd/topic.go&lt;/code&gt;中。&lt;/p&gt;

&lt;h1 id=&#34;topic的获取:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的获取&lt;/h1&gt;

&lt;p&gt;Topic通过&lt;code&gt;GetTopic&lt;/code&gt;函数获取&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// GetTopic performs a thread safe operation
// to return a pointer to a Topic object (potentially new)
func (n *NSQD) GetTopic(topicName string) *Topic {
	n.Lock()

	t, ok := n.topicMap[topicName]
	if ok {
		n.Unlock()
		return t
	}
	deleteCallback := func(t *Topic) {
		n.DeleteExistingTopic(t.name)
	}
	t = NewTopic(topicName, &amp;amp;context{n}, deleteCallback)
	n.topicMap[topicName] = t

	n.logf(&amp;quot;TOPIC(%s): created&amp;quot;, t.name)

	// release our global nsqd lock, and switch to a more granular topic lock while we init our
	// channels from lookupd. This blocks concurrent PutMessages to this topic.
	t.Lock()
	n.Unlock()

	// if using lookupd, make a blocking call to get the topics, and immediately create them.
	// this makes sure that any message received is buffered to the right channels
	lookupdHTTPAddrs := n.lookupdHTTPAddrs()
	if len(lookupdHTTPAddrs) &amp;gt; 0 {
		channelNames, _ := n.ci.GetLookupdTopicChannels(t.name, lookupdHTTPAddrs)
		for _, channelName := range channelNames {
			if strings.HasSuffix(channelName, &amp;quot;#ephemeral&amp;quot;) {
				// we don&#39;t want to pre-create ephemeral channels
				// because there isn&#39;t a client connected
				continue
			}
			t.getOrCreateChannel(channelName)
		}
	}

	t.Unlock()

	// NOTE: I would prefer for this to only happen in topic.GetChannel() but we&#39;re special
	// casing the code above so that we can control the locks such that it is impossible
	// for a message to be written to a (new) topic while we&#39;re looking up channels
	// from lookupd...
	//
	// update messagePump state
	select {
	case t.channelUpdateChan &amp;lt;- 1:
	case &amp;lt;-t.exitChan:
	}
	return t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GetTopic&lt;/code&gt;函数用于获取topic对象，首先先尝试从&lt;code&gt;topicMap&lt;/code&gt;表中获取，如果指定的topic存在，则直接返回topic对象。&lt;/p&gt;

&lt;p&gt;当topic不存在时需要新建一个topic，加入到&lt;code&gt;topicMap&lt;/code&gt;中，
如果启用了nsqlookupd则需要从&lt;code&gt;lookupd&lt;/code&gt;中获取该topic的所有channel，在去除&lt;code&gt;#ephemeral&lt;/code&gt;结尾的临时channel后加入到topic中。&lt;/p&gt;

&lt;p&gt;其中锁的使用值得学习：在调用完nsqd的变量后转而进行topic操作，这时候程序转而使用topic的小粒度的锁，释放了nsqd全局的大粒度锁，
在保证线程安全的同时减少了效率上的损失。&lt;/p&gt;

&lt;p&gt;在创建新的topic后需要向&lt;code&gt;channelUpdateChan&lt;/code&gt;发送消息来更新topic中的channel，而&lt;code&gt;channelUpdateChan&lt;/code&gt;是一个阻塞的go channel,
所以此处使用了&lt;code&gt;select&lt;/code&gt;，并同时监听了&lt;code&gt;exitChan&lt;/code&gt;。如果此时&lt;code&gt;exitChan&lt;/code&gt;收到信号则可以正常退出&lt;code&gt;select&lt;/code&gt;。
如果没有&lt;code&gt;case &amp;lt;-t.exitChan&lt;/code&gt;这句话，
则可能接收&lt;code&gt;channelUpdateChan&lt;/code&gt;的go channel已经退出，但是发送端却还在阻塞中。当然，可以通过退出主go channel来结束程序，
但这样做可能造成部分析构的代码没有得到执行，而且在部分场景下，
只是程序的一个go channel结束运行（在nsqd的这个例子中是topic被删除）而非整个程序退出。
为了避免这个问题，nsqd许多向go channal发送消息的地方都使用了这种机制。&lt;/p&gt;

&lt;p&gt;以下是这种机制的一个示例，
可以通过&lt;a href=&#34;http://play.golang.org/p/xLaZcgjypS&#34;&gt;The Go Playground&lt;/a&gt;来运行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	workerChan := make(chan string)
	exitChan := make(chan int)
	go func() {
		&amp;lt;-time.After(time.Second * 1)
		select {
		case workerChan &amp;lt;- &amp;quot;Task 1&amp;quot;:
		}
		fmt.Println(&amp;quot;Task 1 exit&amp;quot;)
	}()
	go func() {
		select {
		case workerChan &amp;lt;- &amp;quot;Task 2&amp;quot;:
		case &amp;lt;- exitChan:
		}
		fmt.Println(&amp;quot;Task 2 exit&amp;quot;)
	}()
	
	go func() {
		select {
		case &amp;lt;-time.After(time.Second * 2):
		}
		fmt.Println(&amp;quot;Close exitChan&amp;quot;)
		close(exitChan)
		&amp;lt;-time.After(time.Second * 4)
		close(workerChan)
	}()
	
	&amp;lt;- time.After(time.Second * 3)
	fmt.Println(&amp;quot;Start receive from workerChan&amp;quot;)
	loop:
	for {
		select {
		case i, ok := &amp;lt;-workerChan:
			if ok {
				fmt.Println(&amp;quot;Receive:&amp;quot;, i)
			} else {
				break loop
			}
		
		}
	}
		
	
	&amp;lt;- time.After(time.Second * 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行程序，得到以下运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Close exitChan
Task 2 exit
Start receive from workerChan
Receive: Task 1
Task 1 exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Task1和Task2是两个生产者，它们都向workerChan发送消息，其中Task2立即发送，Task1有一定延时，workerChan是一个阻塞的go channel。
同时，有一个go channel发送结束信号（关闭exitChan）。随后开启消费者，接收workerChan的消息，
Task1和Task2的区别是Task2在select中多了一个对exitChan的监听。&lt;/p&gt;

&lt;p&gt;从结果可以看出，当exitChan被关闭时，Task2结束对workerChan的阻塞，取消了像worker发送信号，同时结束了自身。
而没有监听exitChan的Task1依然在阻塞，直到被读取后才退出。&lt;/p&gt;

&lt;p&gt;示例说明了可以通过对exitChan的使用来结束对阻塞go channel的等待。需要说明的是，在真实场景中，
消费者在发出结束的意图后可能并不会去处理尚未被处理的消息，所以像示例中的Task1是无法正常结束的。&lt;/p&gt;

&lt;h1 id=&#34;topic的创建:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的创建&lt;/h1&gt;

&lt;p&gt;当&lt;code&gt;GetTopic&lt;/code&gt;未在已存在的topic中找到指定topic时，就会使用&lt;code&gt;NewTopic&lt;/code&gt;函数新建一个&lt;code&gt;Topic&lt;/code&gt;对象。
&lt;code&gt;Topic&lt;/code&gt;和&lt;code&gt;NewTopic&lt;/code&gt;都位于&lt;code&gt;nsqd/topic.go&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewTopic(topicName string, ctx *context, deleteCallback func(*Topic)) *Topic {
	t := &amp;amp;Topic{
		name:              topicName,
		channelMap:        make(map[string]*Channel),
		memoryMsgChan:     make(chan *Message, ctx.nsqd.getOpts().MemQueueSize),
		exitChan:          make(chan int),
		channelUpdateChan: make(chan int),
		ctx:               ctx,
		pauseChan:         make(chan bool),
		deleteCallback:    deleteCallback,
	}

	if strings.HasSuffix(topicName, &amp;quot;#ephemeral&amp;quot;) {
		t.ephemeral = true
		t.backend = newDummyBackendQueue()
	} else {
		t.backend = newDiskQueue(topicName,
			ctx.nsqd.getOpts().DataPath,
			ctx.nsqd.getOpts().MaxBytesPerFile,
			int32(minValidMsgLength),
			int32(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,
			ctx.nsqd.getOpts().SyncEvery,
			ctx.nsqd.getOpts().SyncTimeout,
			ctx.nsqd.getOpts().Logger)
	}

	t.waitGroup.Wrap(func() { t.messagePump() })

	t.ctx.nsqd.Notify(t)

	return t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewTopic&lt;/code&gt;函数首先创建了一个&lt;code&gt;Topic&lt;/code&gt;结构，然后判断该topic是不是一个临时topic。topic中有个名为&lt;code&gt;backend&lt;/code&gt;的变量，
其类型为&lt;code&gt;Backend&lt;/code&gt;接口。对于临时topic，
消息只储存在内存中，因此&lt;code&gt;backend&lt;/code&gt;变量使用&lt;code&gt;newDummyBackendQueue&lt;/code&gt;函数初始化。该函数生成一个无任何功能的&lt;code&gt;dummyBackendQueue&lt;/code&gt;结构；
对于永久的topic，&lt;code&gt;backend&lt;/code&gt;使用&lt;code&gt;newDiskQueue&lt;/code&gt;函数返回&lt;code&gt;diskQueue&lt;/code&gt;类型赋值，并开启新的goroutine来进行数据的持久化。
&lt;code&gt;dummyBackendQueue&lt;/code&gt;和&lt;code&gt;diskQueue&lt;/code&gt;都实现了&lt;code&gt;Backend&lt;/code&gt;接口，因此，在之后可以使用&lt;code&gt;backend&lt;/code&gt;统一处理。&lt;/p&gt;

&lt;p&gt;随后，&lt;code&gt;NewTopic&lt;/code&gt;函数开启一个新的goroutine来执行&lt;code&gt;messagePump&lt;/code&gt;函数，该函数负责消息循环，将进入topic中的消息投递到channel中。&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;NewTopic&lt;/code&gt;函数执行&lt;code&gt;t.ctx.nsqd.Notify(t)&lt;/code&gt;，该函数在topic和channel创建、停止的时候调用，
&lt;code&gt;Notify&lt;/code&gt;函数通过执行&lt;code&gt;PersistMetadata&lt;/code&gt;函数，将topic和channel的信息写到文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (n *NSQD) Notify(v interface{}) {
	// since the in-memory metadata is incomplete,
	// should not persist metadata while loading it.
	// nsqd will call `PersistMetadata` it after loading
	persist := atomic.LoadInt32(&amp;amp;n.isLoading) == 0
	n.waitGroup.Wrap(func() {
		// by selecting on exitChan we guarantee that
		// we do not block exit, see issue #123
		select {
		case &amp;lt;-n.exitChan:
		case n.notifyChan &amp;lt;- v:
			if !persist {
				return
			}
			n.Lock()
			err := n.PersistMetadata()
			if err != nil {
				n.logf(&amp;quot;ERROR: failed to persist metadata - %s&amp;quot;, err)
			}
			n.Unlock()
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Notify&lt;/code&gt;函数的实现时，首先考虑了数据持久化的时机，如果当前nsqd尚在初始化，则不需要立即持久化数据，因为nsqd在初始化后会进行一次统一的持久化工作，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Notify&lt;/code&gt;在进行数据持久化的时候采用了异步的方式。使得topic和channel能以同步的方式来调用Nofity而不阻塞。在异步运行的过程中，
通过&lt;code&gt;waitGroup&lt;/code&gt;和监听&lt;code&gt;exitChan&lt;/code&gt;的使用保证了结束程序时goroutine能正常退出。&lt;/p&gt;

&lt;p&gt;在执行持久化之前，&lt;code&gt;case n.notifyChan &amp;lt;- v:&lt;/code&gt;语句向&lt;code&gt;notifyChan&lt;/code&gt;传递消息，触发&lt;code&gt;lookupLoop&lt;/code&gt;函数（&lt;code&gt;nsqd/lookup.go&lt;/code&gt;中）接收&lt;code&gt;notifyChan&lt;/code&gt;消息的部分，
从而实现向&lt;code&gt;loopupd&lt;/code&gt;注册/取消注册响应的topic或channel。&lt;/p&gt;

&lt;h1 id=&#34;消息进入topic:efd667b960aa7ec362edb15e7af0b343&#34;&gt;消息进入topic&lt;/h1&gt;

&lt;p&gt;客户端通过nsqd的HTTP API或TCP API向特定topic发送消息，nsqd的HTTP或TCP模块通过调用对应topic的&lt;code&gt;PutMessage&lt;/code&gt;或&lt;code&gt;PutMessages&lt;/code&gt;函数，
将消息投递到topic中。&lt;code&gt;PutMessage&lt;/code&gt;或&lt;code&gt;PutMessages&lt;/code&gt;函数都通过topic的私有函数&lt;code&gt;put&lt;/code&gt;进行消息的投递，两个函数的区别仅在&lt;code&gt;PutMessage&lt;/code&gt;只调用一次&lt;code&gt;put&lt;/code&gt;，
&lt;code&gt;PutMessages&lt;/code&gt;遍历所有要投递的消息，对每条消息使用&lt;code&gt;put&lt;/code&gt;函数进行投递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) put(m *Message) error {
	select {
	case t.memoryMsgChan &amp;lt;- m:
	default:
		// ...
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;带缓冲的go-channel的特性:efd667b960aa7ec362edb15e7af0b343&#34;&gt;带缓冲的Go channel的特性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;put&lt;/code&gt;函数使用了一个带缓冲的go channel的特性：如果case里的go channel阻塞了，那么就会跳过该case语句，执行default分支。即，如果当前&lt;code&gt;memoryMsgChan&lt;/code&gt;还有足够缓冲空间，
则消息被投入&lt;code&gt;memoryMsgChan&lt;/code&gt;，如果当前&lt;code&gt;memoryMsgChan&lt;/code&gt;的缓冲区已满，则将执行default分支，从而将消息保存到&lt;code&gt;backend&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;对于临时topic，由于&lt;code&gt;backend&lt;/code&gt;不进行任何操作，这就意味着消息在内存的缓存满了之后会被直接丢弃，对于永久的channel，则&lt;code&gt;backend&lt;/code&gt;会将该消息持久化到磁盘的文件中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;put&lt;/code&gt;函数使用了Golang的channel特性，大大简化了实现这个逻辑的代码量，以下通过一个简单的示例看看Golang的带缓冲的channel的这一特性，
示例可以通过&lt;a href=&#34;http://play.golang.org/p/UKc0IUleyU&#34;&gt;The Golang Playground&lt;/a&gt;运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	workerChan := make(chan string, 3)
	worker2Chan := make(chan string)
	exitChan := make(chan bool)
	
	go func() {
		for {
			select {
			case str := &amp;lt;- workerChan:
				fmt.Println(&amp;quot;Worker1 receive &amp;quot;, str)
				&amp;lt;- time.After(time.Second * 1)
			case str := &amp;lt;- worker2Chan:
				fmt.Println(&amp;quot;Worker2 receive &amp;quot;, str)
			case &amp;lt;- exitChan:
				return
			}
		}	
	}()
	go func() {
		&amp;lt;- time.After(time.Second * 1)
		workerChan &amp;lt;- &amp;quot;Task 1&amp;quot;
		workerChan &amp;lt;- &amp;quot;Task 2&amp;quot;
		workerChan &amp;lt;- &amp;quot;Task 3&amp;quot;
		select {
		case workerChan &amp;lt;- &amp;quot;Task 4&amp;quot;:
		case worker2Chan &amp;lt;- &amp;quot;Task 5&amp;quot;:
		default:
			fmt.Println(&amp;quot;Channel queue full&amp;quot;)
		}
	}()
	
	&amp;lt;- time.After(time.Second * 5)
	close(exitChan)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Channel queue full
Worker1 receive  Task 1
Worker1 receive  Task 2
Worker1 receive  Task 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例程序中有3个go channel，&lt;code&gt;workerChan&lt;/code&gt;和&lt;code&gt;worker2Chan&lt;/code&gt;用于处理消息，&lt;code&gt;exitChan&lt;/code&gt;用于程序的退出。
当消费者go channel启动后，启动一个生产者go channel向&lt;code&gt;workerChan&lt;/code&gt;连续发送3个消息，
&lt;code&gt;time.After&lt;/code&gt;模拟了消费者在处理&lt;code&gt;workerChan&lt;/code&gt;的消息时出现的延迟，而&lt;code&gt;workerChan&lt;/code&gt;的缓冲区只有3，
因此当消费者向&lt;code&gt;workerChan&lt;/code&gt;发送第4个消息的时候会被阻塞，从运行结果看，没有消息被投向&lt;code&gt;worker2Chan&lt;/code&gt;，
程序在遇到阻塞时进入了default分支，打印出&lt;code&gt;Channel queue full&lt;/code&gt;。特定场景下合理使用这一特性能够大幅减少程序的复杂度。&lt;/p&gt;

&lt;h2 id=&#34;put-函数对消息的持久化:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;put&lt;/code&gt;函数对消息的持久化&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := bufferPoolGet()
err := writeMessageToBackend(b, m, t.backend)
bufferPoolPut(b)
t.ctx.nsqd.SetHealth(err)
if err != nil {
	t.ctx.nsqd.logf(
		&amp;quot;TOPIC(%s) ERROR: failed to write message to backend - %s&amp;quot;,
		t.name, err)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上部分来自函数的default分支，用于将消息持久化到磁盘文件中，过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;bufferPoolGet&lt;/code&gt;函数从buffer池中获取一个buffer，&lt;code&gt;bufferPoolGet&lt;/code&gt;及以下&lt;code&gt;bufferPoolPut&lt;/code&gt;函数是对&lt;code&gt;sync.Pool&lt;/code&gt;的简单包装。
两个函数位于&lt;code&gt;nsqd/buffer_pool.go&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;writeMessageToBackend&lt;/code&gt;函数将消息写入磁盘。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;bufferPoolPut&lt;/code&gt;函数将buffer归还buffer池。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;SetHealth&lt;/code&gt;函数将&lt;code&gt;writeMessageToBackend&lt;/code&gt;的返回值写入&lt;code&gt;errValue&lt;/code&gt;变量。
该变量衍生出&lt;code&gt;IsHealthy&lt;/code&gt;，&lt;code&gt;GetError&lt;/code&gt;和&lt;code&gt;GetHealth&lt;/code&gt;3个函数，主要用于测试以及从HTTP API获取nsqd的运行情况（是否发生错误）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func writeMessageToBackend(buf *bytes.Buffer, msg *Message, bq BackendQueue) error {
	buf.Reset()
	_, err := msg.WriteTo(buf)
	if err != nil {
		return err
	}
	return bq.Put(buf.Bytes())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;writeMessageToBackend&lt;/code&gt;函数重新初始化缓存，将&lt;code&gt;Message&lt;/code&gt;类型的消息序列化到缓存中，最后将缓存写入&lt;code&gt;backend&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;topic消息循环:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic消息循环&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;函数负责Topic的消息循环，该函数在创建新的topic时通过&lt;code&gt;waitGroup&lt;/code&gt;在新的goroutine中运行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;函数初始化时先获取当前存在的channel数组，设置&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;，随后进入消息循环，
在循环中主要处理四种消息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接收来自&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;两个go channel进入的消息，并向当前的channal数组中的channel进行投递&lt;/li&gt;
&lt;li&gt;处理当前topic下channel的更新&lt;/li&gt;
&lt;li&gt;处理当前topic的暂停和恢复&lt;/li&gt;
&lt;li&gt;监听当前topic的删除&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;消息投递:efd667b960aa7ec362edb15e7af0b343&#34;&gt;消息投递&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case msg = &amp;lt;-memoryMsgChan:
case buf = &amp;lt;-backendChan:
	msg, err = decodeMessage(buf)
	if err != nil {
		t.ctx.nsqd.logf(&amp;quot;ERROR: failed to decode message - %s&amp;quot;, err)
		continue
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个case语句处理进入topic的消息，关于两个go channel的区别会在后续的博客中分析。
从&lt;code&gt;memoryMsgChanbackendChan&lt;/code&gt;读取到的消息是&lt;code&gt;*Message&lt;/code&gt;类型，而从&lt;code&gt;backendChan&lt;/code&gt;读取到的消息是&lt;code&gt;byte&lt;/code&gt;数组的。
因此取出&lt;code&gt;backendChan&lt;/code&gt;的消息后海需要调用&lt;code&gt;decodeMessage&lt;/code&gt;函数对&lt;code&gt;byte&lt;/code&gt;数组进行解码，返回&lt;code&gt;*Message&lt;/code&gt;类型的消息。
二者都保存在&lt;code&gt;msg&lt;/code&gt;变量中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, channel := range chans {
	chanMsg := msg
	// copy the message because each channel
	// needs a unique instance but...
	// fastpath to avoid copy if its the first channel
	// (the topic already created the first copy)
	if i &amp;gt; 0 {
		chanMsg = NewMessage(msg.ID, msg.Body)
		chanMsg.Timestamp = msg.Timestamp
		chanMsg.deferred = msg.deferred
	}
	if chanMsg.deferred != 0 {
		channel.StartDeferredTimeout(chanMsg, chanMsg.deferred)
		continue
	}
	err := channel.PutMessage(chanMsg)
	if err != nil {
		t.ctx.nsqd.logf(
			&amp;quot;TOPIC(%s) ERROR: failed to put msg(%s) to channel(%s) - %s&amp;quot;,
			t.name, msg.ID, channel.name, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后是将消息投到每个channel中，首先先对消息进行复制操作，这里有个优化，对于第一次循环，
直接使用原消息进行发送以减少复制对象的开销，此后的循环将对消息进行复制。对于即时的消息，
直接调用channel的&lt;code&gt;PutMessage&lt;/code&gt;函数进行投递，对于延迟的消息，
调用channel的&lt;code&gt;StartDeferredTimeout&lt;/code&gt;函数进行投递。对于这两个函数的投递细节，后续博文中会详细分析。&lt;/p&gt;

&lt;h2 id=&#34;topic下channel的更新:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic下Channel的更新&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case &amp;lt;-t.channelUpdateChan:
	chans = chans[:0]
	t.RLock()
	for _, c := range t.channelMap {
		chans = append(chans, c)
	}
	t.RUnlock()
	if len(chans) == 0 || t.IsPaused() {
		memoryMsgChan = nil
		backendChan = nil
	} else {
		memoryMsgChan = t.memoryMsgChan
		backendChan = t.backend.ReadChan()
	}
	continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel的更新比较简单，从&lt;code&gt;channelMap&lt;/code&gt;中取出每个channel，构成channel的数组以便后续进行消息的投递。
并且根据当前是否有channel以及该topic是否处于暂停状态来决定&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;是否为空。&lt;/p&gt;

&lt;h2 id=&#34;topic的暂停和恢复:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的暂停和恢复&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case pause := &amp;lt;-t.pauseChan:
	if pause || len(chans) == 0 {
		memoryMsgChan = nil
		backendChan = nil
	} else {
		memoryMsgChan = t.memoryMsgChan
		backendChan = t.backend.ReadChan()
	}
	continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个case既处理topic的暂停也处理topic的恢复，&lt;code&gt;pause&lt;/code&gt;变量决定其究竟是哪一种操作。
Topic的暂停和恢复其实和topic的更新很像，根据是否暂停以及是否有channel来决定是否分配&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;messagepump-函数的退出:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;messagePump&lt;/code&gt;函数的退出&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case &amp;lt;-t.exitChan:
	goto exit

// ...
exit:
	t.ctx.nsqd.logf(&amp;quot;TOPIC(%s): closing ... messagePump&amp;quot;, t.name)
}
// End of messagePump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;通过监听&lt;code&gt;exitChan&lt;/code&gt;来获知topic是否被删除，当topic的删除时，跳转到函数的最后，输出日志后退出消息循环。&lt;/p&gt;

&lt;h1 id=&#34;topic的关闭和删除:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的关闭和删除&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Delete empties the topic and all its channels and closes
func (t *Topic) Delete() error {
	return t.exit(true)
}

// Close persists all outstanding topic data and closes all its channels
func (t *Topic) Close() error {
	return t.exit(false)
}

func (t *Topic) exit(deleted bool) error {
	if !atomic.CompareAndSwapInt32(&amp;amp;t.exitFlag, 0, 1) {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}

	if deleted {
		t.ctx.nsqd.logf(&amp;quot;TOPIC(%s): deleting&amp;quot;, t.name)

		// since we are explicitly deleting a topic (not just at system exit time)
		// de-register this from the lookupd
		t.ctx.nsqd.Notify(t)
	} else {
		t.ctx.nsqd.logf(&amp;quot;TOPIC(%s): closing&amp;quot;, t.name)
	}

	close(t.exitChan)

	// synchronize the close of messagePump()
	t.waitGroup.Wait()

	if deleted {
		t.Lock()
		for _, channel := range t.channelMap {
			delete(t.channelMap, channel.name)
			channel.Delete()
		}
		t.Unlock()

		// empty the queue (deletes the backend files, too)
		t.Empty()
		return t.backend.Delete()
	}

	// close all the channels
	for _, channel := range t.channelMap {
		err := channel.Close()
		if err != nil {
			// we need to continue regardless of error to close all the channels
			t.ctx.nsqd.logf(&amp;quot;ERROR: channel(%s) close - %s&amp;quot;, channel.name, err)
		}
	}

	// write anything leftover to disk
	t.flush()
	return t.backend.Close()
}
// Exiting returns a boolean indicating if this topic is closed/exiting
func (t *Topic) Exiting() bool {
	return atomic.LoadInt32(&amp;amp;t.exitFlag) == 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Topic关闭和删除的实现都是调用&lt;code&gt;exit&lt;/code&gt;函数，只是传递的参数不同，删除时调用&lt;code&gt;exit(true)&lt;/code&gt;，关闭时调用&lt;code&gt;exit(false)&lt;/code&gt;。
&lt;code&gt;exit&lt;/code&gt;函数进入时通过&lt;code&gt;atomic.CompareAndSwapInt32&lt;/code&gt;函数判断当前是否正在退出，如果不是，则设置退出标记，对于已经在退出的topic，不再重复执行退出函数。
接着对于关闭操作，使用&lt;code&gt;Notify&lt;/code&gt;函数通知lookupd以便其他nsqd获知该消息。&lt;/p&gt;

&lt;p&gt;随后，&lt;code&gt;exit&lt;/code&gt;函数调用&lt;code&gt;close(t.exitChan)&lt;/code&gt;和&lt;code&gt;t.waitGroup.Wait()&lt;/code&gt;通知其他正在运行goroutine当前topic已经停止，并等待&lt;code&gt;waitGroup&lt;/code&gt;中的goroutine结束运行。&lt;/p&gt;

&lt;p&gt;最后，对于删除和关闭两种操作，执行不同的逻辑来完成最后的清理工作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于删除操作，需要清空&lt;code&gt;channelMap&lt;/code&gt;并删除所有channel，然后删除内存和磁盘中所有未投递的消息。最后关闭&lt;code&gt;backend&lt;/code&gt;管理的的磁盘文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于关闭操作，不清空&lt;code&gt;channelMap&lt;/code&gt;，只是关闭所有的channel，使用&lt;code&gt;flush&lt;/code&gt;函数将所有&lt;code&gt;memoryMsgChan&lt;/code&gt;中未投递的消息用&lt;code&gt;writeMessageToBackend&lt;/code&gt;保存到磁盘中。最后关闭&lt;code&gt;backend&lt;/code&gt;管理的的磁盘文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) flush() error {
	//...
	for {
		select {
		case msg := &amp;lt;-t.memoryMsgChan:
			err := writeMessageToBackend(&amp;amp;msgBuf, msg, t.backend)
			if err != nil {
				t.ctx.nsqd.logf(
					&amp;quot;ERROR: failed to write message to backend - %s&amp;quot;, err)
			}
		default:
			goto finish
		}
	}
	
finish:
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flush&lt;/code&gt;函数也使用到了default分支来检测是否已经处理完全部消息。
由于此时已经没有生产者向&lt;code&gt;memoryMsgChan&lt;/code&gt;提供消息，因此如果出现阻塞就表示消息已经处理完毕。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) Empty() error {
	for {
		select {
		case &amp;lt;-t.memoryMsgChan:
		default:
			goto finish
		}
	}

finish:
	return t.backend.Empty()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在删除topic时用到的&lt;code&gt;Empty&lt;/code&gt;函数跟&lt;code&gt;flush&lt;/code&gt;处理逻辑类似，只不过&lt;code&gt;Empty&lt;/code&gt;只释放&lt;code&gt;memoryMsgChan&lt;/code&gt;消息，而不保存它们。&lt;/p&gt;

&lt;h1 id=&#34;其他函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;其他函数&lt;/h1&gt;

&lt;h2 id=&#34;depth-函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;Depth&lt;/code&gt;函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) Depth() int64 {
	return int64(len(t.memoryMsgChan)) + t.backend.Depth()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Depth&lt;/code&gt;函数用于获取当前topic尚未投递的消息数，是&lt;code&gt;memoryMsgChan&lt;/code&gt;缓冲区的长度加上&lt;code&gt;backend&lt;/code&gt;里消息的个数。&lt;/p&gt;

&lt;h2 id=&#34;pause-和-unpause-函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;Pause&lt;/code&gt;和&lt;code&gt;UnPause&lt;/code&gt;函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) Pause() error {
	return t.doPause(true)
}

func (t *Topic) UnPause() error {
	return t.doPause(false)
}

func (t *Topic) doPause(pause bool) error {
	if pause {
		atomic.StoreInt32(&amp;amp;t.paused, 1)
	} else {
		atomic.StoreInt32(&amp;amp;t.paused, 0)
	}

	select {
	case t.pauseChan &amp;lt;- pause:
	case &amp;lt;-t.exitChan:
	}

	return nil
}

func (t *Topic) IsPaused() bool {
	return atomic.LoadInt32(&amp;amp;t.paused) == 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于很多相似的处理逻辑，nsqd在对外使用不同的函数，但在内部实现上通常把它们合并为一个函数来处理，只是传递的参数不同而已，
比如前面提到的&lt;code&gt;Close&lt;/code&gt;和&lt;code&gt;Delete&lt;/code&gt;。&lt;code&gt;Pause&lt;/code&gt;和&lt;code&gt;UnPause&lt;/code&gt;同样也使用这种方式，通过传递不同的参数调用&lt;code&gt;doPause&lt;/code&gt;函数来执行不同操作。
&lt;code&gt;doPause&lt;/code&gt;设置&lt;code&gt;paused&lt;/code&gt;标志并向&lt;code&gt;pauseChan&lt;/code&gt;发送消息，随后由&lt;code&gt;messagePump&lt;/code&gt;在消息循环中暂停topic。&lt;/p&gt;

&lt;h2 id=&#34;aggregatechannele2eprocessinglatency-函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;AggregateChannelE2eProcessingLatency&lt;/code&gt;函数&lt;/h2&gt;

&lt;p&gt;此函数用于性能统计，在&lt;code&gt;nsqd/statd.go&lt;/code&gt;中调用，客户端可以通过HTTP的/stats API看到统计结果。具体细节将在后续博文分析。&lt;/p&gt;

&lt;h2 id=&#34;与channel相关的函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;与channel相关的函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;GetChannel&lt;/code&gt;, &lt;code&gt;getOrCreateChannel&lt;/code&gt;，&lt;code&gt;GetExistingChannel&lt;/code&gt;, &lt;code&gt;DeleteExistingChannel&lt;/code&gt;这些函数是与channel相关的函数，将在后续的博文中分析。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nsq源码阅读笔记之nsqd（一）——nsqd的配置解析和初始化</title>
      <link>http://blog.rayxxzhang.com/2015/11/12/nsqd-source-1-init/</link>
      <pubDate>Thu, 12 Nov 2015 22:50:13 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/11/12/nsqd-source-1-init/</guid>
      <description>

&lt;h1 id=&#34;配置解析:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;配置解析&lt;/h1&gt;

&lt;p&gt;nsqd的主函数位于&lt;code&gt;apps/nsqd.go&lt;/code&gt;中的&lt;code&gt;main&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;flagSet := nsqFlagset()
flagSet.Parse(os.Args[1:])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先&lt;code&gt;main&lt;/code&gt;函数调用&lt;code&gt;nsqFlagset&lt;/code&gt;和&lt;code&gt;Parse&lt;/code&gt;进行命令行参数集初始化，
然后判断&lt;code&gt;version&lt;/code&gt;参数是否存在，若存在，则打印版本号并退出程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;signalChan := make(chan os.Signal, 1)
signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)
//...
&amp;lt;-signalChan
nsqd.Exit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来钩住系统的&lt;code&gt;syscall.SIGINT&lt;/code&gt;和&lt;code&gt;syscall.SIGTERM&lt;/code&gt;消息，用来阻塞主goroutine防止退出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var cfg config
configFile := flagSet.Lookup(&amp;quot;config&amp;quot;).Value.String()
if configFile != &amp;quot;&amp;quot; {
	_, err := toml.DecodeFile(configFile, &amp;amp;cfg)
	if err != nil {
		log.Fatalf(&amp;quot;ERROR: failed to load config file %s - %s&amp;quot;, configFile, err.Error())
	}
}
cfg.Validate()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后判断&lt;code&gt;config&lt;/code&gt;参数是否存在，若存在的话还需进行配置文件的读取，
nsq使用toml格式的配置文件，并通过&lt;code&gt;github.com/BurntSushi/toml&lt;/code&gt;库进行配置文件的读取和解析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (cfg config) Validate() {
	// special validation/translation
	if v, exists := cfg[&amp;quot;tls_required&amp;quot;]; exists {
		var t tlsRequiredOption
		err := t.Set(fmt.Sprintf(&amp;quot;%v&amp;quot;, v))
		if err == nil {
			cfg[&amp;quot;tls_required&amp;quot;] = t.String()
		} else {
			log.Fatalf(&amp;quot;ERROR: failed parsing tls required %v&amp;quot;, v)
		}
	}
	if v, exists := cfg[&amp;quot;tls_min_version&amp;quot;]; exists {
		var t tlsVersionOption
		err := t.Set(fmt.Sprintf(&amp;quot;%v&amp;quot;, v))
		if err == nil {
			newVal := fmt.Sprintf(&amp;quot;%v&amp;quot;, t.Get())
			if newVal != &amp;quot;0&amp;quot; {
				cfg[&amp;quot;tls_min_version&amp;quot;] = newVal
			} else {
				delete(cfg, &amp;quot;tls_min_version&amp;quot;)
			}
		} else {
			log.Fatalf(&amp;quot;ERROR: failed parsing tls min version %v&amp;quot;, v)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果配置文件存在并且符合toml格式，则调用&lt;code&gt;cfg.Validate&lt;/code&gt;对配置文件的各项进行进一步的合法性检查。
主要是检查配置文件中有关tls的选项（是否支持以及支持的版本）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;opts := nsqd.NewOptions()
options.Resolve(opts, flagSet, cfg)
nsqd := nsqd.New(opts)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件检查通过后，创建默认配置&lt;code&gt;opts&lt;/code&gt;，并于命令行参数和配置文件进行合并。
合并时用到了&lt;code&gt;github.com/mreiferson/go-options&lt;/code&gt;库。
若出现冲突，则优先级从高到低排序依次是命令行、配置文件和默认配置
使用合并后的参数集初始化真正的nsqd对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;nsqd.LoadMetadata()
err := nsqd.PersistMetadata()
if err != nil {
	log.Fatalf(&amp;quot;ERROR: failed to persist metadata - %s&amp;quot;, err.Error())
}
nsqd.Main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，nsqd对象进行初始化和检查后，启动nsqd包的主函数，程序从跳转&lt;code&gt;apps/nsqd.go&lt;/code&gt;到&lt;code&gt;nsqd/nsqd.go&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;初始化:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;初始化&lt;/h1&gt;

&lt;p&gt;nsqd真正开始运行前需要执行&lt;code&gt;nsqd/nsqd.go&lt;/code&gt;中的&lt;code&gt;LoadMetadata&lt;/code&gt;和&lt;code&gt;PersistMetadata&lt;/code&gt;两个函数&lt;/p&gt;

&lt;h2 id=&#34;loadmetadata:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;LoadMetadata&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// nsqd/nsqd.go
atomic.StoreInt32(&amp;amp;n.isLoading, 1)
defer atomic.StoreInt32(&amp;amp;n.isLoading, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化nsqd的&lt;code&gt;LoadMetadata&lt;/code&gt;函数使用&lt;code&gt;atomic&lt;/code&gt;包中的方法来保证方法执行前和执行后&lt;code&gt;isLoading&lt;/code&gt;值的改变&lt;/p&gt;

&lt;p&gt;元数据以&lt;code&gt;json&lt;/code&gt;格式保存在nsqd可执行文件目录下的*nsqd.%d.dat*中。其中&lt;code&gt;%d&lt;/code&gt;为代表该程序的ID，
通过在启动时的命令行&lt;code&gt;worker-id&lt;/code&gt;或者配置文件中的&lt;code&gt;id&lt;/code&gt;指定。默认ID是通过对主机名散列后获得。
因此保证了同一台机器每次启动的ID相同。&lt;/p&gt;

&lt;p&gt;解析元数据的文件得到系统中的存在的topic列表，遍历topic列表中的每个topic：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查topic名称是否合法（长度在1-64之间，满足正则表达式&lt;code&gt;^[\.a-zA-Z0-9_-]+(#ephemeral)?$&lt;/code&gt;）
，若不合法则忽略&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;GetTopic&lt;/code&gt;函数通过名字获得topic对象&lt;/li&gt;
&lt;li&gt;判断当前topic对象是否处于暂停状态，是的话调用&lt;code&gt;Pause&lt;/code&gt;函数暂停topic&lt;/li&gt;
&lt;li&gt;获取当前topic下所有的channel，并且遍历channel，执行的操作与topic基本一致

&lt;ol&gt;
&lt;li&gt;检查channel名称是否合法（长度在1-64之间，满足正则表达式&lt;code&gt;^[\.a-zA-Z0-9_-]+(#ephemeral)?$&lt;/code&gt;）
，若不合法则忽略&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;GetChannel&lt;/code&gt;函数通过名字获得channel对象&lt;/li&gt;
&lt;li&gt;判断当前channel对象是否处于暂停状态，是的话调用&lt;code&gt;Pause&lt;/code&gt;函数暂停channel&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，元数据的载入完成&lt;/p&gt;

&lt;h2 id=&#34;persistmetadata:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;PersistMetadata&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PersistMetadata&lt;/code&gt;将当前的topic和channel信息写入*nsqd.%d.dat*文件中,
主要步骤是忽略&lt;code&gt;#ephemeral&lt;/code&gt;结尾的topic和channel后将topic和channel列表json序列化后写回文件中&lt;/p&gt;

&lt;p&gt;写入文件时先创建扩展名为tmp的临时文件，写入内容后并保存后再调用&lt;code&gt;atomicRename&lt;/code&gt;函数将tmp文件重命名为*nsqd.%d.dat*。
其中&lt;code&gt;atomicRename&lt;/code&gt;函数在windows和其他操作系统下实现方式不同，分别位于&lt;code&gt;nsqd/rename_windows.go&lt;/code&gt;
和&lt;code&gt;rename.go&lt;/code&gt;中。在Linux下直接调用了&lt;code&gt;os.Rename&lt;/code&gt;函数，而Windows下则使用Win32 API实现了文件的重命名。
这是因为go的早期版本中Windows下调用&lt;code&gt;os.Rename&lt;/code&gt;函数时如果重命名后的文件已经存在则会失败。
这个bug在&lt;a href=&#34;https://github.com/golang/go/issues/8914&#34;&gt;os: make Rename atomic on Windows&lt;/a&gt;中提到，
并且已经在&lt;a href=&#34;https://github.com/golang/go/commit/92c57363e0b4d193c4324e2af6902fe56b7524a0&#34;&gt;os: windows Rename should overwrite destination file.&lt;/a&gt;提交中被修复，
因此，Golang1.5不存在这一bug&lt;/p&gt;

&lt;h2 id=&#34;main:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;Main&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;Main&lt;/code&gt;函数中，nsqd真正开始运行。&lt;code&gt;Main&lt;/code&gt;监听tcp，https（如果设置了相关参数），http端口并通过&lt;code&gt;WaitGroupWrapper&lt;/code&gt;的&lt;code&gt;Wrap&lt;/code&gt;函数以goroutine方式启动主要的组件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type WaitGroupWrapper struct {
	sync.WaitGroup
}

func (w *WaitGroupWrapper) Wrap(cb func()) {
	w.Add(1)
	go func() {
		cb()
		w.Done()
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;WaitGroupWrapper&lt;/code&gt;是对&lt;code&gt;sync.WaitGroup&lt;/code&gt;的简单包装&lt;/p&gt;

&lt;p&gt;执行完&lt;code&gt;Main&lt;/code&gt;函数后，配置和初始化工作全部完成，各个组件启动运行，而主goroutine会阻塞在&lt;code&gt;&amp;lt;-signalChan&lt;/code&gt;处，直到收到中断程序的信号，随后执行&lt;code&gt;nsqd.Exit&lt;/code&gt;函数。
&lt;code&gt;Exit&lt;/code&gt;函数将进行&lt;code&gt;socket&lt;/code&gt;关闭等清理工作，随后结束整个程序的运行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>从Eclipse迁移到Android Studio</title>
      <link>http://blog.rayxxzhang.com/2015/10/29/migrate_to_android_studio/</link>
      <pubDate>Thu, 29 Oct 2015 16:48:16 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/10/29/migrate_to_android_studio/</guid>
      <description>

&lt;p&gt;Android Studio发布正式版后，Google的重心转向AS，以后可能也会逐步停止对Eclipse的支持，而且目前开源项目有很多以及不支持Eclipse。因此决心将项目转到Android Studio进行开发。&lt;/p&gt;

&lt;h2 id=&#34;安装:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Android Studio的安装需要联网并且下载Android SDK和gradle等等才能使用。
同时AS的使用需要配合相应位数的JDK，并且JDK的路径需要设置到JAVA_HOME环境变量。&lt;/p&gt;

&lt;p&gt;AS的安装包大约300-400MB，但安装好后加上SDK等等其他依赖，占用空间可能达到8GB以上。
因此如果能获取到AS安装后的文件也可以直接复制使用。复制时需要复制Android Studio安装文件夹，SDK文件夹，以及个人目录下的.gradle和.androidstudiox.y文件夹，其中x.y为AS的版本号，其中存放着AS的配置。&lt;/p&gt;

&lt;h2 id=&#34;导入:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;导入&lt;/h2&gt;

&lt;p&gt;Eclipse项目迁移到AS的第一步是更新Eclipse的AJDT插件，然后在文件菜单选择导出，将Eclipse工程导出成AS工程。导出后会在目录下生成build.gradle文件，
然后在AS选择导入非AS工程的选项即可导入，第一次使用由于需要分析构建整个项目，所以速度会比较慢。&lt;/p&gt;

&lt;h2 id=&#34;注意事项:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;注意事项&lt;/h2&gt;

&lt;h3 id=&#34;so库的支持:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;so库的支持&lt;/h3&gt;

&lt;p&gt;如果是纯java的项目，导入后就基本能编译运行了，如果项目中还依赖so库，
可以通过在build.gradle文件中添加jniLibs.srcDirs = [&amp;lsquo;so文件的目录&amp;rsquo;]来导入so库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
	// 其他配置
	sourceSets {
		main {
			//其他配置
			jniLibs.srcDirs = [&#39;libs&#39;]
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;meta-inf中文件重复的问题:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;META-INF中文件重复的问题&lt;/h3&gt;

&lt;p&gt;有些第三方库会在META-INF文件夹中放一些版权说明的文件，如果不止一个库在放了同名的文件，
在打包时gradle就无法决定应META-INF文件夹中应该使用哪个文件。&lt;/p&gt;

&lt;p&gt;这种情况下，可以通过在build.gradle文件中排除这些文件来解决。
版权文件的文件名通常是LICENSE, NOTICE, license.txt, notice.txt之一。
因此可以通过如下配置排除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
	// 其他配置
	packagingOptions {
		exclude &#39;META-INF/LICENSE&#39;
		exclude &#39;META-INF/NOTICE&#39;
		exclude &#39;META-INF/license.txt&#39;
		exclude &#39;META-INF/notice.txt&#39;
		// 还可添加其他要排除的文件
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法也可以用于排除其他不想被打包到APK里的文件。&lt;/p&gt;

&lt;h2 id=&#34;小技巧:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;小技巧&lt;/h2&gt;

&lt;h3 id=&#34;动态设置编译版本号:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;动态设置编译版本号&lt;/h3&gt;

&lt;p&gt;build.gradle文件中可以设置编译出的APK的版本号，如果设置了版本号，则会覆盖Manifest.xml中设置的版本号。&lt;/p&gt;

&lt;p&gt;这样，就给我们提供了一个动态修改编译版本号的方法。如果版本控制使用了SVN，就可以通过编写如下函数来实现动态获取SVN版本号和编译时间：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;
def getVersionCode = {
    try {
        def code = new ByteArrayOutputStream()
        exec {
            commandLine &#39;用于获取版本号的命令&#39;
            standardOutput = code
        }
        return Integer.valueOf(code.toString().split(&amp;quot;\r\n&amp;quot;)[0])
    }
    catch (ignored) {
        return 0;
    }
}
def getVersionName = {
    try {
        def code = new ByteArrayOutputStream()
        exec {
            commandLine &#39;用于获取版本号的命令&#39;
            standardOutput = code
        }
        def date = new ByteArrayOutputStream()
        exec {
            commandLine &#39;用于获取编译时间的命令&#39;
            standardOutput = date
        }
        return code.toString().split(&amp;quot;\r\n&amp;quot;)[0] + &amp;quot;.&amp;quot; + date.toString().split(&amp;quot;\n&amp;quot;)[0]
    }
    catch (ignored) {
        return &amp;quot;&amp;quot;;
    }
}

android {
    updateSVNInfo()
    defaultConfig {
        versionCode getVersionCode()
        versionName getVersionName()
        minSdkVersion 8
        targetSdkVersion 23
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;apk签名配置:f5e1f5a0cf21ff198e5b3684e50f3611&#34;&gt;APK签名配置&lt;/h3&gt;

&lt;p&gt;在Eclipse里debug版本的签名只能使用默认的签名，而在Android Studio中可以通过build.gradle来配置签名所使用的证书：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
	// 其他配置
	signingConfigs {
        debug {
            storeFile file(&amp;quot;签名密钥路径&amp;quot;)
            keyAlias &#39;密钥Alias&#39;
            keyPassword &#39;密钥密码&#39;
            storePassword &#39;存储密码&#39;
        }
		// 可以指定其他编译类型的配置，如release
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置debug和release使用一样的签名就避免了在debug和release混合安装的时候出现签名错误需要重新卸载后再安装的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang实现带优先级的channel</title>
      <link>http://blog.rayxxzhang.com/2015/10/29/golang_priority_channel/</link>
      <pubDate>Thu, 29 Oct 2015 15:32:52 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/10/29/golang_priority_channel/</guid>
      <description>&lt;p&gt;一般Go语言同时使用多个&lt;code&gt;channel&lt;/code&gt;的方法是使用&lt;code&gt;select&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;语句配合&lt;code&gt;&amp;lt;-&lt;/code&gt;操作符，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
case &amp;lt;- chan1:
	// do something
case &amp;lt;- chan2:
	// do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这种实现方式下&lt;code&gt;chan1&lt;/code&gt;和&lt;code&gt;chan2&lt;/code&gt;是同等优先级的。如果要实现带优先级的&lt;code&gt;channel&lt;/code&gt;则需要用到&lt;code&gt;defalut&lt;/code&gt;语句。&lt;/p&gt;

&lt;p&gt;在go语言中，如果&lt;code&gt;select&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;中没有&lt;code&gt;default&lt;/code&gt;子句，则程序会阻塞在&lt;code&gt;select&lt;/code&gt;中，直到其中一个&lt;code&gt;case&lt;/code&gt;语句接收到了数据。
如果有&lt;code&gt;default&lt;/code&gt;语句，则不会阻塞，如果&lt;code&gt;case&lt;/code&gt;接收到数据，就执行&lt;code&gt;case&lt;/code&gt;中的语句，如果&lt;code&gt;case&lt;/code&gt;未收到信号，则会执行&lt;code&gt;defalut&lt;/code&gt;中的语句，随后跳出&lt;code&gt;select&lt;/code&gt;块。&lt;/p&gt;

&lt;p&gt;使用这个特性可以实现带优先级的&lt;code&gt;channel&lt;/code&gt;队列。以2个优先级的&lt;code&gt;channel&lt;/code&gt;举例，实现方法是使用多层&lt;code&gt;select&lt;/code&gt;，将高优先级&lt;code&gt;channel&lt;/code&gt;放在最外层&lt;code&gt;select&lt;/code&gt;语句的&lt;code&gt;case&lt;/code&gt;后，并跟上一个&lt;code&gt;default&lt;/code&gt;语句以免当高优先级的&lt;code&gt;channel&lt;/code&gt;没有数据时阻塞。
&lt;code&gt;defalut&lt;/code&gt;内依然是一个&lt;code&gt;select&lt;/code&gt;语句，在这个&lt;code&gt;select&lt;/code&gt;语句中，将高优先级和低优先级的&lt;code&gt;case&lt;/code&gt;都放入，并且没有&lt;code&gt;default&lt;/code&gt;语句。这样内层&lt;code&gt;select&lt;/code&gt;就会阻塞直到其中一个&lt;code&gt;case&lt;/code&gt;收到数据。&lt;/p&gt;

&lt;p&gt;这种实现方式相当于高优先级的&lt;code&gt;channel&lt;/code&gt;比低优先级的多了一次被处理的机会，即外层&lt;code&gt;select&lt;/code&gt;，只有高优先级没有数据时，才会执行内层&lt;code&gt;select&lt;/code&gt;，此时先产生数据的&lt;code&gt;channel&lt;/code&gt;先被执行。&lt;/p&gt;

&lt;p&gt;也就是说，当高优先级和低优先级都有数据时，高优先级先被处理，也就是实现了优先级。示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for {
	select {
	case data := &amp;lt;- highChan:
		handleHigh(data)
	default:
		select {
		case data := &amp;lt;- highChan:
			handleHigh(data)
		case data := &amp;lt;- lowChan:
			handleLow(data)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>POJ1059解题报告</title>
      <link>http://blog.rayxxzhang.com/2015/09/24/poj1059/</link>
      <pubDate>Thu, 24 Sep 2015 22:55:21 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/09/24/poj1059/</guid>
      <description>

&lt;h1 id=&#34;题目概览:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;题目概览&lt;/h1&gt;

&lt;h2 id=&#34;标题:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;Chutes and Ladders&lt;/p&gt;

&lt;h2 id=&#34;要求:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Time Limit: 1000MS&lt;/li&gt;
&lt;li&gt;Memory Limit: 10000K&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题目描述:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;A popular board game for children is called &amp;ldquo;Chutes and Ladders&amp;rdquo;. The board has squares which are numbered from 1 to 100, and players have counters which start on the theoretical square 0. The players take turns at throwing a die with the numbers 1 to 6 on it, and each moves his or her counter forward the number of squares corresponding to the number on the die (the square they reach is found by adding the die number to the square number their counter is on). The first person to reach square 100 is the winner.&lt;/p&gt;

&lt;p&gt;The interest is caused by the fact that pairs of squares are connected together by &amp;ldquo;ladders&amp;rdquo; (which connect a lower-numbered square to a higher-numbered square) and &amp;ldquo;chutes&amp;rdquo; (which run from high to low). If a counter lands on the start of a chute or ladder (i.e., this is the square reached after throwing the die), then the counter is moved to the corresponding square at the end of the chute or ladder. Note that landing on the end square of a ladder or a chute has no effect, only the start square counts. Furthermore, there are some squares such that if a player&amp;rsquo;s counter lands on them, then the player must either miss the next turn, or immediately throw the die again for another turn, depending on what is written on the board. A miss-a-turn or extra-turn square is never the start or end of a ladder or chute. If a player is on square 95 or higher, then a die throw which takes them past 100 must be ignored - thus a player on square 99 must ignore all throws which are not 1.&lt;/p&gt;

&lt;h2 id=&#34;输入:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;Input will start with a set of less than 1000 die throws which you must use for all games, starting each new game with the first player &amp;ldquo;throwing&amp;rdquo; the first number in the set, the next player &amp;ldquo;throwing&amp;rdquo; the second number, and so on. This set of die throws will simply be a list of random numbers between 1 and 6, separated by single spaces, with not more than 80 characters on each line. It will be terminated by the number 0. After this set of die throws, there will be one or more game sets. Each game set is in three parts. The first part is a line containing a single number giving the number of players in the game. This will be more than 1 and less than 6. Then the board is described, in two parts. The first part lists the ladders and the chutes on the board, each ladder or chute being defined on a single line. Each is given by two numbers, from 1 to 99,separated by one or more spaces. The first number gives the start square, and the second number gives the end square; so it is a ladder if the first number is less than the second number, and a chute if the order is the other way. The chute/ladder definitions are terminated by a line containing two 0&amp;rsquo;s. The second part of the board description gives the lose-a-turn/extra-turn squares, if there are any. These are single numbers, one per line, defining the squares. If the number is negative, its positive counterpart is a lose-a-turn square; if positive, it represents an extra-turn square. (For example, -16 means that square 16 on the board is a lose-a-turn square, while a 25 means that players landing on square 25 must immediately roll again.) The end of this set of descriptions, and of the game description, is given by a single 0. The end of all the game descriptions is given by a game with the number of players equal to 0.&lt;/p&gt;

&lt;h2 id=&#34;输出:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;输出&lt;/h2&gt;

&lt;p&gt;Output must be one line for each game in the input, giving the number of the player who wins the game. Every game will determine a winner in fewer throws than those given at the start of the data.&lt;/p&gt;

&lt;h2 id=&#34;示例输入:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;示例输入&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;2&lt;/p&gt;

&lt;p&gt;6 95&lt;/p&gt;

&lt;p&gt;99 1&lt;/p&gt;

&lt;p&gt;0 0&lt;/p&gt;

&lt;p&gt;-3&lt;/p&gt;

&lt;p&gt;98&lt;/p&gt;

&lt;p&gt;0&lt;/p&gt;

&lt;p&gt;2&lt;/p&gt;

&lt;p&gt;3 99&lt;/p&gt;

&lt;p&gt;6 90&lt;/p&gt;

&lt;p&gt;0 0&lt;/p&gt;

&lt;p&gt;0&lt;/p&gt;

&lt;p&gt;0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;示例输出:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;示例输出&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;分析:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;分析&lt;/h1&gt;

&lt;p&gt;本题属于模拟题，虽然通过率不高，但实际上并不难，只要理解了题意模拟游戏场景就能顺利做出来。&lt;/p&gt;

&lt;p&gt;题意说的是若干个玩家玩一个叫飞行棋的游戏，棋盘有101格，分别标0-100，游戏开始时所有玩家都在0格，游戏中玩家轮流掷骰子（1-6点），&lt;/p&gt;

&lt;p&gt;若当前格子编号加上骰子掷出的点数小于等于100，则前进骰子掷出的点数个格子，否则不动。前进后有几种情况，若格子是一个“梯子格”，就会从该格前进到指定的更大点数的格子，若格子是一个“滑梯格”，&lt;/p&gt;

&lt;p&gt;就会从该格后退到指定的点数小的格子。每个格子还有一个属性，多掷一次骰子或者停一轮，如果最后落到有这两个属性之一的格子里，&lt;/p&gt;

&lt;p&gt;则多掷一次骰子，或者下一轮轮空一次。先到达100点的为胜者。&lt;/p&gt;

&lt;p&gt;解题用到了&lt;code&gt;vector&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;结构，&lt;code&gt;vector&lt;/code&gt;用于保存输入的点数列表，&lt;code&gt;map&lt;/code&gt;结构用于存放“梯子/滑梯对”以及“多掷一次/轮空一次”。&lt;/p&gt;

&lt;p&gt;最后的&lt;code&gt;set&lt;/code&gt;用于存放模拟时轮空一次的玩家编号。&lt;/p&gt;

&lt;p&gt;要注意玩家编号若从0开始，最后输出的时候需要加1。&lt;/p&gt;

&lt;h1 id=&#34;源码:47fa44fa87bdadb13bbc958230fb603b&#34;&gt;源码&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;map&amp;gt;
#include&amp;lt;set&amp;gt;

using namespace std;
int main() {
	// 点数列表
	vector&amp;lt;int&amp;gt; dies;
	while(true) {
		int count;
		cin &amp;gt;&amp;gt; count;
		if (count != 0) {
			dies.push_back(count);
		}
		else {
			break;
		}
	}
	while (true) {
		int playerNum;
		// 初始化玩家数
		cin &amp;gt;&amp;gt; playerNum;
		if (playerNum == 0) {
			break;
		}
		// 初始化 chutes&amp;amp;ladders 表
		map&amp;lt;int, int&amp;gt; chutes_or_ladders_map;
		while (true) {
			int start, end;
			cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;
			if (start == 0 &amp;amp;&amp;amp; end == 0) {
				break;
			}
			chutes_or_ladders_map.insert(make_pair(start, end));
		}
		// “多掷一次/轮空一次”表
		map&amp;lt;int, bool&amp;gt; lose_or_extra_map;
		while (true) {
			int in;
			cin &amp;gt;&amp;gt; in;
			if (in == 0) {
				break;
			}
			else if(in &amp;gt; 0){
				// 多掷一次
				lose_or_extra_map.insert(make_pair(in, true));
			}
			else {
				// 轮空一次
				lose_or_extra_map.insert(make_pair(-in, false));
			}
		}
		// 初始化玩家
		int *players = new int[playerNum]();
		// 当前掷骰子的玩家编号
		int currentPlayer = 0;
		vector&amp;lt;int&amp;gt;::iterator it = dies.begin();
		int num = 0;
		set&amp;lt;int&amp;gt; passes;
		while (true) {
			// 开始模拟
			if (passes.find(currentPlayer) != passes.end()) {
				// 当前玩家在轮空表中，先从轮空列表中删除该玩家
				passes.erase(currentPlayer);
				// 对当前玩家编号自增
				if (++currentPlayer == playerNum) {
					// 注意循环玩家编号
					currentPlayer = 0;
				}
				continue;
			}
			if (it == dies.end()) {
				// 防止骰子点数用尽，做循环
				it = dies.begin();
			}
			// 保存当前玩家的格子编号，提高效率
			num = players[currentPlayer];
			// 如果当前格子数不大于100，前进
			int tmp = num + *it;
			++it;
			if (tmp &amp;lt; 100) {
				num = tmp;
			}
			else if (tmp == 100) {
				// 到100格，结束游戏
				cout &amp;lt;&amp;lt; currentPlayer + 1 &amp;lt;&amp;lt; endl;
				break;
			}
			// 前进后查询是否在“梯子/滑梯”格中
			if (chutes_or_ladders_map.find(num) != chutes_or_ladders_map.end()) {
				// 前进或后退相应格数
				num = chutes_or_ladders_map[num];
			}
			// 写回结果
			players[currentPlayer] = num;
			if (lose_or_extra_map.find(num) != lose_or_extra_map.end()) {
				if (lose_or_extra_map[num] == true) {
					// 多掷一次
				}
				else {
					// 轮空一次
					passes.insert(currentPlayer);
					if (++currentPlayer == playerNum) {
						currentPlayer = 0;
					}
				}
			}
			else {
				if (++currentPlayer == playerNum) {
					currentPlayer = 0;
				}
			}
		}
		// 释放玩家列表内存
		delete[] players;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Windows下PyInstaller的使用教程</title>
      <link>http://blog.rayxxzhang.com/2015/09/15/pyinstaller/</link>
      <pubDate>Tue, 15 Sep 2015 20:33:06 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/09/15/pyinstaller/</guid>
      <description>

&lt;p&gt;直接使用Python开发的软件时有许多不方便的地方，如需要安装特定的Python环境，需要安装依赖库。为了便于部署，需要将Python源代码编译成可执行文件，编译后的可执行文件就能脱离python环境运行了。&lt;/p&gt;

&lt;h1 id=&#34;安装:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;将py编译成可执行文件需要使用&lt;a href=&#34;https://github.com/pyinstaller/&#34;&gt;PyInstaller&lt;/a&gt;，需要注意，从百度搜索到的下载链接来自SourceForge，而PyInstaller的开发似乎已经转到Github上去了，因此从SourceForge上下载的版本不是最新的。&lt;/p&gt;

&lt;p&gt;目前最新的PyInstaller版本是2.1，最方便的安装方式是通过&lt;code&gt;pip&lt;/code&gt;使用如下命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install pyinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以通过&lt;a href=&#34;https://github.com/pyinstaller/pyinstaller/releases&#34;&gt;下载&lt;/a&gt;源代码编译方式安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后，使用如下命令可以确认版本号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pyinstaller --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示&lt;code&gt;Error: Python 2.6+ on Windows support need pywin32&lt;/code&gt;，则说明当前没有安装&lt;a href=&#34;http://sourceforge.net/projects/pywin32/files/pywin32/&#34;&gt;pywin32&lt;/a&gt;，安装后即可正常运行PyInstaller。
安装pywin32时需要注意，pywin32的版本和本机Python位数和版本必须相同。&lt;/p&gt;

&lt;h1 id=&#34;简单使用:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;简单使用&lt;/h1&gt;

&lt;p&gt;最简单的使用方式是运行&lt;code&gt;pyinstaller myscript.py&lt;/code&gt;来生成可执行文件，其中&lt;code&gt;myscript.py&lt;/code&gt;是需要编译成可执行文件的源代码。
通过这种方式生成的可执行文件默认位于当前文件夹的dist目录下的myscript目录中，该目录下除了有exe文件外，还有若干个其他文件，这些文件都是运行时必须的。
编译完成后可以删除build文件夹，该文件夹存放的是编译过程中的生成的临时文件&lt;/p&gt;

&lt;p&gt;如果希望编译出的exe文件不依赖其他文件，可以添加&lt;code&gt;-F&lt;/code&gt;选项：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pyinstaller -F myscript.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;编译出的单独的exe文件在启动时速度上略慢于编译成文件夹方式。因为在执行单独的exe时会将资源先释放到临时文件夹中再执行。&lt;/p&gt;

&lt;h1 id=&#34;常用选项:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;常用选项&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;distpath=path_to_executable, -o path_to_executable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;指定生成的可执行文件存放的目录，默认存放在dist目录下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;workpath=path_to_work_files&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;指定编译中临时文件存放的目录，默认存放在build目录下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;clean&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;清理编译时的临时文件&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-F, &amp;ndash;onefile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成单独的exe文件而不是文件夹&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-d, &amp;ndash;debug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编译为debug模式，有助于运行中获取日志信息&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;version-file=version_text_file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为exe文件添加版本信息，版本信息可以通过运行&lt;code&gt;pyi-grab_version&lt;/code&gt;加上要获取版本信息的exe文件的路径来生成，生成后的版本信息文件可以按需求修改并作为&lt;code&gt;--version-file&lt;/code&gt;的参数添加到要生成的exe文件中去&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;i &amp;lt;FILE.ico&amp;gt;, -i &amp;lt;FILE.exe,ID&amp;gt;, &amp;ndash;icon=&amp;lt;FILE.ico&amp;gt;, &amp;ndash;icon=&amp;lt;FILE.exe,ID&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为exe文件添加图标，可以指定图标路径或者从已存在的exe文件中抽取特定的ID的图标作为要生成的exe文件的图标&lt;/p&gt;

&lt;p&gt;另外，还可以通过spec文件来生成可执行文件，运行&lt;code&gt;pyi-makespec options script [script ...]&lt;/code&gt;可以生成spec文件，修改spec文件后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pyinstaller specfile

或者

pyi-build specfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以生成可执行文件了。&lt;/p&gt;

&lt;p&gt;spec文件方式生成可执行文件提供了更多的定制选项，包括自定义python库的位置，要打包的其他文件路径等等。&lt;/p&gt;

&lt;h2 id=&#34;更多:1b70070a7208f70b6a3e9d9aa27f8fdb&#34;&gt;更多&lt;/h2&gt;

&lt;p&gt;更多的使用选项及错误解决方法可以参照PyInstaller的&lt;a href=&#34;http://pythonhosted.org/PyInstaller/&#34;&gt;官方帮助文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>POJ1003解题报告</title>
      <link>http://blog.rayxxzhang.com/2015/09/14/poj1003/</link>
      <pubDate>Mon, 14 Sep 2015 21:35:12 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/09/14/poj1003/</guid>
      <description>

&lt;h1 id=&#34;题目概览:2e98549788b10e1ae8406221df07f9c6&#34;&gt;题目概览&lt;/h1&gt;

&lt;h2 id=&#34;标题:2e98549788b10e1ae8406221df07f9c6&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;Handover&lt;/p&gt;

&lt;h2 id=&#34;要求:2e98549788b10e1ae8406221df07f9c6&#34;&gt;要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Time Limit: 1000MS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory Limit: 10000K&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题目描述:2e98549788b10e1ae8406221df07f9c6&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We&amp;rsquo;re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; = &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;6&lt;/sub&gt; card lengths. In general you can make n cards overhang by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; + &amp;hellip; + 1/(n + 1) card lengths, where the top card overhangs the second by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, the second overhangs tha third by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;, the third overhangs the fourth by &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;, etc., and the bottom card overhangs the table by 1/(n + 1). This is illustrated in the figure below.&lt;/p&gt;

&lt;h2 id=&#34;输入:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;The input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. Each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits.&lt;/p&gt;

&lt;h2 id=&#34;输出:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输出&lt;/h2&gt;

&lt;p&gt;For each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. Use the exact output format shown in the examples.&lt;/p&gt;

&lt;h2 id=&#34;输入示例:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输入示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;1.00&lt;/p&gt;

&lt;p&gt;3.71&lt;/p&gt;

&lt;p&gt;0.04&lt;/p&gt;

&lt;p&gt;5.19&lt;/p&gt;

&lt;p&gt;0.00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;输出示例:2e98549788b10e1ae8406221df07f9c6&#34;&gt;输出示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;3 card(s)&lt;/p&gt;

&lt;p&gt;61 card(s)&lt;/p&gt;

&lt;p&gt;1 card(s)&lt;/p&gt;

&lt;p&gt;273 card(s)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;解题报告:2e98549788b10e1ae8406221df07f9c6&#34;&gt;解题报告&lt;/h1&gt;

&lt;h2 id=&#34;分析:2e98549788b10e1ae8406221df07f9c6&#34;&gt;分析&lt;/h2&gt;

&lt;p&gt;本题较简单，可以采用map+vector的方式提高效率，vector用于保存原始的数据顺序，map可以根据数据大小自动排序。&lt;/p&gt;

&lt;p&gt;在计算的时候可以将每一步的计算结果与map的迭代器里的数比较，如果符合，则将取出map中的下一个数，这样能仅进行一遍计算就能得到全部结果。&lt;/p&gt;

&lt;p&gt;最后输出的时候键的顺序采用vector里保存的顺序（即原始顺序），值则采用map中的值。&lt;/p&gt;

&lt;h2 id=&#34;源码:2e98549788b10e1ae8406221df07f9c6&#34;&gt;源码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;map&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
int main() {
    string item;
    vector&amp;lt;double&amp;gt; input;
    map&amp;lt;double, int&amp;gt; sorted;
    double num;
    while (true) {
        cin &amp;gt;&amp;gt; item;
        if (item == &amp;quot;0.00&amp;quot;) {
            break;
        }
        num = item[0] - &#39;0&#39; + (item[2] - &#39;0&#39;) * 0.1 + (item[3] - &#39;0&#39;) * 0.01;
        input.push_back(num);
        sorted.insert(make_pair(num, 0));
    }
    double result = 0;
    map&amp;lt;double, int&amp;gt;::iterator it = sorted.begin();
    for (int i = 2; it != sorted.end(); ++i) {
        result += 1.0 / i;
        while (result &amp;gt; it-&amp;gt;first) {
            it-&amp;gt;second = i - 1;
            ++it;
            if (it == sorted.end()) {
                break;
            }
        }
    }
    for (vector&amp;lt;double&amp;gt;::iterator itv = input.begin(); itv != input.end(); ++itv) {
        cout &amp;lt;&amp;lt; sorted[*itv] &amp;lt;&amp;lt; &amp;quot; card(s)&amp;quot; &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>POJ1002解题报告</title>
      <link>http://blog.rayxxzhang.com/2015/09/14/poj1002/</link>
      <pubDate>Mon, 14 Sep 2015 19:05:45 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/09/14/poj1002/</guid>
      <description>

&lt;h1 id=&#34;题目概览:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;题目概览&lt;/h1&gt;

&lt;h2 id=&#34;标题:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;487-3279&lt;/p&gt;

&lt;h2 id=&#34;要求:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Time Limit: 2000MS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory Limit: 65536K&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;题目描述:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;Businesses like to have memorable telephone numbers. One way to make a telephone number memorable is to have it spell a memorable word or phrase. For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP. Sometimes only part of the number is used to spell a word. When you get back to your hotel tonight you can order a pizza from Gino&amp;rsquo;s by dialing 310-GINO. Another way to make a telephone number memorable is to group the digits in a memorable way. You could order your pizza from Pizza Hut by calling their &amp;lsquo;three tens&amp;rsquo; number 3-10-10-10.&lt;/p&gt;

&lt;p&gt;The standard form of a telephone number is seven decimal digits with a hyphen between the third and fourth digits (e.g. 888-1200). The keypad of a phone supplies the mapping of letters to numbers, as follows:&lt;/p&gt;

&lt;p&gt;A, B, and C map to 2
D, E, and F map to 3
G, H, and I map to 4
J, K, and L map to 5
M, N, and O map to 6
P, R, and S map to 7
T, U, and V map to 8
W, X, and Y map to 9&lt;/p&gt;

&lt;p&gt;There is no mapping for Q or Z. Hyphens are not dialed, and can be added and removed as necessary. The standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010.&lt;/p&gt;

&lt;p&gt;Two telephone numbers are equivalent if they have the same standard form. (They dial the same number.)&lt;/p&gt;

&lt;p&gt;Your company is compiling a directory of telephone numbers from local businesses. As part of the quality control process you want to check that no two (or more) businesses in the directory have the same telephone number.&lt;/p&gt;

&lt;h2 id=&#34;输入:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;The input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters.&lt;/p&gt;

&lt;h2 id=&#34;输出:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输出&lt;/h2&gt;

&lt;p&gt;Generate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line:&lt;/p&gt;

&lt;p&gt;No duplicates.&lt;/p&gt;

&lt;h2 id=&#34;输入示例:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输入示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;12&lt;/p&gt;

&lt;p&gt;4873279&lt;/p&gt;

&lt;p&gt;ITS-EASY&lt;/p&gt;

&lt;p&gt;888-4567&lt;/p&gt;

&lt;p&gt;3-10-10-10&lt;/p&gt;

&lt;p&gt;888-GLOP&lt;/p&gt;

&lt;p&gt;TUT-GLOP&lt;/p&gt;

&lt;p&gt;967-11-11&lt;/p&gt;

&lt;p&gt;310-GINO&lt;/p&gt;

&lt;p&gt;F101010&lt;/p&gt;

&lt;p&gt;888-1200&lt;/p&gt;

&lt;p&gt;-4-8-7-3-2-7-9-&lt;/p&gt;

&lt;p&gt;487-3279&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;输出示例:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;输出示例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;310-1010 2&lt;/p&gt;

&lt;p&gt;487-3279 4&lt;/p&gt;

&lt;p&gt;888-4567 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;解题报告:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;解题报告&lt;/h1&gt;

&lt;h2 id=&#34;分析:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;分析&lt;/h2&gt;

&lt;p&gt;需要将输入还原成数字，可以有几种方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以构建字符和数字映射的哈希表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;table[&#39;A&#39;] = table[&#39;B&#39;] = table[&#39;C&#39;] = 1;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以使用 &lt;code&gt;switch&lt;/code&gt; 语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;switch(oneChar) {
    case &#39;A&#39;:
    case &#39;B&#39;:
    case &#39;C&#39;:
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要将解析出的数字放入哈希表或者数组中以便统计出现个数。如果使用C++的map，则最后输出时还能实现自动的排序。&lt;/p&gt;

&lt;h2 id=&#34;c-的map容器学习:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;C++的map容器学习&lt;/h2&gt;

&lt;h3 id=&#34;头文件:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;头文件&lt;/h3&gt;

&lt;p&gt;使用map需引用map头文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;map&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;声明:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;声明&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map&amp;lt;int, string&amp;gt; map1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11前map的初始化只能通过[]下标操作或者insert函数实现，C++11引入了新的map初始化方式，可以通过如下方式进行初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map&amp;lt;int, string&amp;gt; map1 = {{1, &amp;quot;A&amp;quot;}, {2, &amp;quot;B&amp;quot;}};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;插入:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;插入&lt;/h3&gt;

&lt;p&gt;插入操作可以使用[]下标操作或者insert函数。两者的区别是当要的键之前存在时，[]会更新原来的值，而insert则不会更新，并且返回值为 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;insert有很多个重载，其中最常用的一个重载接受一个pair类型作为参数，可以使用 &lt;code&gt;make_pair&lt;/code&gt; 来创建pair：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map1.insert(make_pair(1, &amp;quot;A&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++11可以通过emplace函数添加新元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map1.emplace(1, &amp;quot;A&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查找:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;查找&lt;/h3&gt;

&lt;p&gt;查找通过find函数。find函数返回一个迭代器，通过判断迭代器是否为end来确认是否查找到了指定的元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;map&amp;lt;int, string&amp;gt;::iterator it = map1.find(1);
if(it != map1.end()) {
	// 找到相应元素	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;访问:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;访问&lt;/h3&gt;

&lt;p&gt;通过使用[]下标操作访问元素，c++11可以通过at函数来访问元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的一点是使用[]下标操作有副作用，即如果该键不存在，会在该键上插入一个有默认值的元素。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;删除:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;删除&lt;/h3&gt;

&lt;p&gt;删除使用earse函数，传入要删除的键即可&lt;/p&gt;

&lt;h3 id=&#34;遍历:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;遍历&lt;/h3&gt;

&lt;p&gt;map通过迭代器遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(map&amp;lt;int, string&amp;gt;::iterator it = map1.begin();it != map1.end(); ++it) {
	// it-&amp;gt;first 是键
	// it-&amp;gt;second 是值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c++11还能通过以下方法遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(auto it: map1) {
	// it.first 是键
	// it.second 是值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其他:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;其他&lt;/h3&gt;

&lt;p&gt;其他函数及详细说明可以参考&lt;a href=&#34;http://www.cplusplus.com/reference/map/map/&#34;&gt;C++ map官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;poj的一些注意事项:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;POJ的一些注意事项&lt;/h2&gt;

&lt;h2 id=&#34;编译:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;C++的编译可以使用POJ提交选项中的C++或者G++编译器，其中C++是VC++的编译器，G++是GNU的编译器。两者均不支持C++11特性。
有些题目使用C++能通过，但G++会超时，有时又相反，因此超时或内存占用过大的情况下可以试着换一下编译器。&lt;/p&gt;

&lt;h2 id=&#34;io:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;IO&lt;/h2&gt;

&lt;p&gt;C++的cin和cout的运行时间比C中的scanf和printf要长，容易超时。且在本题中按字符读取而不是按字符串读取必定超时（未验证，该说法来自[POJ1002-487-3279][5]）&lt;/p&gt;

&lt;h2 id=&#34;stl:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;STL&lt;/h2&gt;

&lt;p&gt;使用STL效率会降低一些&lt;/p&gt;

&lt;h1 id=&#34;源码:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;源码&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;map&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;iomanip&amp;gt;
using namespace std;
class PhoneNumberList {
public:
	explicit PhoneNumberList() :numMap() { };
	void add(string numStr) {
		int number = parse(numStr);
		map&amp;lt;int, int&amp;gt;::iterator it = numMap.find(number);
		if (it == numMap.end()) {
			numMap.insert(make_pair(number, 1));
		}
		else {
			it-&amp;gt;second++;
		}

	}
	friend ostream &amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os, PhoneNumberList &amp;amp;list) {
		bool duplicate = false;
		for (map&amp;lt;int, int&amp;gt;::iterator i = list.numMap.begin(); i != list.numMap.end(); ++i) {
			if (i-&amp;gt;second != 1) {
				os &amp;lt;&amp;lt; setfill(&#39;0&#39;) &amp;lt;&amp;lt; setfill(&#39;0&#39;) &amp;lt;&amp;lt; setw(3) &amp;lt;&amp;lt; i-&amp;gt;first / 10000 &amp;lt;&amp;lt; &amp;quot;-&amp;quot; &amp;lt;&amp;lt; setfill(&#39;0&#39;) &amp;lt;&amp;lt; setw(4) &amp;lt;&amp;lt; i-&amp;gt;first % 10000 &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; endl;
				duplicate = true;
			}
		}
		if (duplicate == false) {
			os &amp;lt;&amp;lt; &amp;quot;No duplicates.&amp;quot; &amp;lt;&amp;lt; endl;
		}
		return os;
	};
private:
	map&amp;lt;int, int&amp;gt; numMap;
	int parse(string numStr) const {
		int result = 0;
		int length = numStr.length();
		for (int i = 0; i &amp;lt; length; ++i) {
			char *c = &amp;amp;numStr[i];
			switch (*c) {
			case &#39;A&#39;:
			case &#39;B&#39;:
			case &#39;C&#39;:
				result = result * 10 + 2;
				break;
			case &#39;D&#39;:
			case &#39;E&#39;:
			case &#39;F&#39;:
				result = result * 10 + 3;
				break;
			case &#39;G&#39;:
			case &#39;H&#39;:
			case &#39;I&#39;:
				result = result * 10 + 4;
				break;
			case &#39;J&#39;:
			case &#39;K&#39;:
			case &#39;L&#39;:
				result = result * 10 + 5;
				break;
			case &#39;M&#39;:
			case &#39;N&#39;:
			case &#39;O&#39;:
				result = result * 10 + 6;
				break;
			case &#39;P&#39;:
			case &#39;R&#39;:
			case &#39;S&#39;:
				result = result * 10 + 7;
				break;
			case &#39;T&#39;:
			case &#39;U&#39;:
			case &#39;V&#39;:
				result = result * 10 + 8;
				break;
			case &#39;W&#39;:
			case &#39;X&#39;:
			case &#39;Y&#39;:
				result = result * 10 + 9;
				break;
			default:
				if (*c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *c &amp;lt;= &#39;9&#39;) {
					result = result * 10 + *c - &#39;0&#39;;
				}
				break;
			}
		}
		return result;
	}
};
int main() {
	int lines;
	PhoneNumberList phoneNumberList;
	cin &amp;gt;&amp;gt; lines;
	string item;
	for (int i = 0; i &amp;lt; lines; ++i) {
		cin &amp;gt;&amp;gt; item;
		phoneNumberList.add(item);
	}
	cout &amp;lt;&amp;lt; phoneNumberList;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考页面:6d7d293e123cc03d5e3f5bc86e7610c3&#34;&gt;参考页面&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://my.oschina.net/skyhacker2/blog/392832&#34;&gt;C++11遍历map&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.itpub.net/16856446/viewspace-626583/&#34;&gt;C++ map[ ]=与insert操作不同&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/liucanrui/article/details/6591029&#34;&gt;C++学习之map类型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/map/map/&#34;&gt;C++ map官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5]: &lt;a href=&#34;http://blog.csdn.net/lyy289065406/article/details/6647348&#34;&gt;http://blog.csdn.net/lyy289065406/article/details/6647348&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Hugo搭建博客</title>
      <link>http://blog.rayxxzhang.com/2015/09/14/first/</link>
      <pubDate>Mon, 14 Sep 2015 18:57:07 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/09/14/first/</guid>
      <description>&lt;p&gt;终于下决心开个博客，之前试过一次，但是太懒，基本没写什么，而且懒得维护服务器。所以这次博客选择用静态页面的方法搭建，静态博客的好处是能专注于内容本身而不是服务器的维护工作。&lt;/p&gt;

&lt;p&gt;假期花了两天时间完成了建立博客的前期准备工作，在此分享一下其中的心得体会：&lt;/p&gt;

&lt;p&gt;博客的托管方面选择的是 &lt;em&gt;Github Pages&lt;/em&gt; ， &lt;em&gt;Github Pages&lt;/em&gt; 可以存放静态的网页，通常被用于架设开源项目的主页以及个人技术博客。
搭建博客以及选择托管在Github上的主要是因为曾经听一个互联网创业公司的创始人说过，写博客是一种很好的习惯，可以记录下自己所学过的知识。这对未来的求职和工作都有帮助。
而Github作为目前最大的开源社区，是技术交流的绝佳平台，相比于国内使用较多的CSDN博客及博客园，Github博客以Github的个人主页更能体现出一个人完整的技术水平。&lt;/p&gt;

&lt;p&gt;关于 &lt;em&gt;Github Pages&lt;/em&gt; 的使用，官方有详细的&lt;a href=&#34;https://help.github.com/categories/github-pages-basics/&#34;&gt;教程&lt;/a&gt;。
官方推荐的架设博客的方式是使用&lt;a href=&#34;https://github.com/jekyll/jekyll&#34;&gt;Jekyll&lt;/a&gt;，不过在看了网上一些对静态博客搭建软件的比较后（&lt;a href=&#34;http://www.zhihu.com/question/20962496&#34;&gt;如何在 GitHub 上写博客？&lt;/a&gt;），最终决定使用Hugo作为搭建博客的工具。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;使用Golang开发，windows版本就一个exe文件，使用方便，并且Github上有许多Hugo的UI主体可供使用。&lt;/p&gt;

&lt;p&gt;在学习使用Hugo的过程中，参考了&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;这篇博文。作者比较详细的说明了如何使用Hugo搭建一个静态博客。
在这里就不详细叙述了，有兴趣可以参考该博文。&lt;/p&gt;

&lt;p&gt;Hugo和Jekyll等软件一样也选择了markdown作为博文的写作格式，这点让我比较喜欢，markdown的写作能在生成比较优雅的外观的同时兼顾源文件的简洁，非常适合技术文章的使用。
尝试了一下Hugo对markdown特性的支持，对标准markdown的支持很好，并且还支持部分&lt;a href=&#34;https://help.github.com/articles/github-flavored-markdown/&#34;&gt;Github flavored markdown&lt;/a&gt;的特性。在此也归纳一下Github官方的markdown教程以便日后查询：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/markdown-basics/&#34;&gt;Markdown basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://guides.github.com/features/mastering-markdown/&#34;&gt;Mastering markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/github-flavored-markdown/&#34;&gt;Github flavored markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Hugo主题选择方面，一个名为&lt;a href=&#34;https://github.com/pdevty/polymer&#34;&gt;Polymer&lt;/a&gt;的主题让我眼前一亮。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/pdevty/polymer/blob/master/images/tn.png?raw=true&#34; alt=&#34;Hugo的Polymer主题&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从Polymer这个名字一眼就可以看出是来自Google的&lt;a href=&#34;https://www.polymer-project.org/1.0/&#34;&gt;Polymer项目&lt;/a&gt;。
作为这两年在Google I/O大会上提及的前端开发框架，它使用了许多新的技术，如web components，shadow DOM等等，把html的一些基础组件封装成了一些十分方便使用的控件，样式优雅开发简单。
仔细看了一下Hugo的Polymer主题的外观以及逻辑，觉得还是有一些小问题需要改进的，比较明显的就是文章页导航按钮和底栏出现了错位。因此，我决定学习一下Google Polymer的使用方法并且把主题中的这些小错误改过来。&lt;/p&gt;

&lt;p&gt;通过对Google Polymer文档的学习以及Polymer主题源码的阅读和调试，找到发生错位的原因是 &lt;code&gt;layouts/partials/content.html&lt;/code&gt; 文件中未将文章正文部分用 &lt;code&gt;&amp;lt;paper-item&amp;gt;&lt;/code&gt; 标签包裹，而导航栏及底栏都使用了 &lt;code&gt;&amp;lt;paper-item&amp;gt;&lt;/code&gt; 标签，
因此导致了html的解析问题，使得正文部分的高度被忽略，所以原本应该显示在底部的底栏发生了显示上的错位。&lt;/p&gt;

&lt;p&gt;除此之外，还在主题上加入了各大网站个人主页链接的自定义排序功能，并且加上的新浪微博的图标。修改了 &lt;strong&gt;标签&lt;/strong&gt; ， &lt;strong&gt;主题&lt;/strong&gt; 两个页面，添加了自定义预设文本的选项，修改了字体大小等细节。
由于修改基于从原项目folk出的新项目上，因此所有的修改都可以在&lt;a href=&#34;https://github.com/123hurray/polymer/&#34;&gt;github.com/123hurray/polymer&lt;/a&gt;的提交记录看到。&lt;/p&gt;

&lt;p&gt;以上工作完成后，基本的准备工作就算结束了。随着这篇博文的发布，博客就算正式建立了。近期的博客发布计划主要是在Android开发中的一些心得及备忘，&lt;a href=&#34;https://poj.org/&#34;&gt;POJ&lt;/a&gt;题目的解题心得等等。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>