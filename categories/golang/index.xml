<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on RayXXZhang的博客</title>
    <link>http://blog.rayxxzhang.com/categories/golang/</link>
    <description>Recent content in Golang on RayXXZhang的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyright RayXXZhang</copyright>
    <lastBuildDate>Mon, 29 Feb 2016 13:51:16 +0800</lastBuildDate>
    <atom:link href="http://blog.rayxxzhang.com/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>nsq源码阅读笔记之nsqd（四）——Channel</title>
      <link>http://blog.rayxxzhang.com/2016/02/29/nsqd_source_4_channels/</link>
      <pubDate>Mon, 29 Feb 2016 13:51:16 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2016/02/29/nsqd_source_4_channels/</guid>
      <description>

&lt;p&gt;与&lt;strong&gt;Channel&lt;/strong&gt;相关的代码主要位于&lt;code&gt;nsqd/channel.go&lt;/code&gt;, &lt;code&gt;nsqd/nsqd.go&lt;/code&gt;中。&lt;/p&gt;

&lt;h1 id=&#34;channel与topic的关系:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;Channel与Topic的关系&lt;/h1&gt;

&lt;p&gt;Channel是消费者订阅特定Topic的一种抽象。对于发往Topic的消息，nsqd向该Topic下的所有Channel投递消息，
而同一个Channel只投递一次，Channel下如果存在多个消费者，则随机选择一个消费者做投递。这种投递方式可以被用作消费者负载均衡。&lt;/p&gt;

&lt;p&gt;Channel从属于特定Topic，可以认为是Topic的下一级。在同一个Topic之下可以有零个或多个Channel。
和Topic一样，Channel同样有永久和临时之分，永久的Channel只能通过显式删除销毁，临时的Channel在最后一个消费者断开连接的时候被销毁。&lt;/p&gt;

&lt;p&gt;与服务于生产者的Topic不同，Channel直接面向消费者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;生产者 -&amp;gt; 消息 -&amp;gt; Topic -&amp;gt; Channel -&amp;gt; 消费者1
                       -&amp;gt; Channel2 -&amp;gt; 消费者2
                       -&amp;gt; Channel3 -&amp;gt; 消费者3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码上Channel和Topic有许多相似之处，对于和Topic相同或者相似的部分，以下不再赘述，可以参考Topic相关博文。&lt;/p&gt;

&lt;h1 id=&#34;channel的创建:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;Channel的创建&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewChannel(topicName string, channelName string, ctx *context,
	deleteCallback func(*Channel)) *Channel {

	c := &amp;amp;Channel{
		topicName:      topicName,
		name:           channelName,
		memoryMsgChan:  make(chan *Message, ctx.nsqd.getOpts().MemQueueSize),
		clientMsgChan:  make(chan *Message),
		exitChan:       make(chan int),
		clients:        make(map[int64]Consumer),
		deleteCallback: deleteCallback,
		ctx:            ctx,
	}
	if len(ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles) &amp;gt; 0 {
		c.e2eProcessingLatencyStream = quantile.New(
			ctx.nsqd.getOpts().E2EProcessingLatencyWindowTime,
			ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles,
		)
	}

	c.initPQ()

	if strings.HasSuffix(channelName, &amp;quot;#ephemeral&amp;quot;) {
		c.ephemeral = true
		c.backend = newDummyBackendQueue()
	} else {
		// backend names, for uniqueness, automatically include the topic...
		backendName := getBackendName(topicName, channelName)
		c.backend = newDiskQueue(backendName,
			ctx.nsqd.getOpts().DataPath,
			ctx.nsqd.getOpts().MaxBytesPerFile,
			int32(minValidMsgLength),
			int32(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,
			ctx.nsqd.getOpts().SyncEvery,
			ctx.nsqd.getOpts().SyncTimeout,
			ctx.nsqd.getOpts().Logger)
	}

	go c.messagePump()

	c.ctx.nsqd.Notify(c)

	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel和Topic在创建的时候都会初始化结构，初始化backend，创建消息循环，
不同的是Channel在创建时多了给&lt;code&gt;e2eProcessingLatencyStream&lt;/code&gt;赋值的以及&lt;code&gt;initPQ&lt;/code&gt;部分。&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;e2eProcessingLatencyStream&lt;/code&gt;主要用于统计消息投递的延迟等，将在以后的博文中叙述。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) initPQ() {
	pqSize := int(math.Max(1, float64(c.ctx.nsqd.getOpts().MemQueueSize)/10))

	c.inFlightMessages = make(map[MessageID]*Message)
	c.deferredMessages = make(map[MessageID]*pqueue.Item)

	c.inFlightMutex.Lock()
	c.inFlightPQ = newInFlightPqueue(pqSize)
	c.inFlightMutex.Unlock()

	c.deferredMutex.Lock()
	c.deferredPQ = pqueue.New(pqSize)
	c.deferredMutex.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;initPQ&lt;/code&gt;函数创建了两个字典&lt;code&gt;inFlightMessages&lt;/code&gt;、&lt;code&gt;deferredMessages&lt;/code&gt;和两个队列&lt;code&gt;inFlightPQ&lt;/code&gt;、&lt;code&gt;deferredPQ&lt;/code&gt;。
在nsq中inFlight指的是正在投递但还没确认投递成功的消息，defferred指的是投递失败，等待重新投递的消息。
&lt;code&gt;initPQ&lt;/code&gt;创建的字典和队列主要用于索引和存放这两类消息。其中两个字典使用消息ID作索引。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inFlightPQ&lt;/code&gt;使用&lt;code&gt;newInFlightPqueue&lt;/code&gt;初始化，&lt;code&gt;InFlightPqueue&lt;/code&gt;位于&lt;code&gt;nsqd\in_flight_pqueue.go&lt;/code&gt;。
&lt;code&gt;nsqd\in_flight_pqueue.go&lt;/code&gt;是nsq实现的一个优先级队列，提供了常用的队列操作，值得学习。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;deferredPQ&lt;/code&gt;使用&lt;code&gt;pqueue.New&lt;/code&gt;初始化，&lt;code&gt;pqueue&lt;/code&gt;位于&lt;code&gt;nsqd\pqueue.go&lt;/code&gt;，也是一个优先级队列。&lt;/p&gt;

&lt;h1 id=&#34;待投递消息进入channel:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;待投递消息进入Channel&lt;/h1&gt;

&lt;p&gt;在分析Topic时提到，消息进入Topic的消息循环后会被投递到该Topic下所有的Channel，由Channel的&lt;code&gt;PutMessage&lt;/code&gt;函数进行处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PutMessage writes a Message to the queue
func (c *Channel) PutMessage(m *Message) error {
	c.RLock()
	defer c.RUnlock()
	if atomic.LoadInt32(&amp;amp;c.exitFlag) == 1 {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}
	err := c.put(m)
	if err != nil {
		return err
	}
	atomic.AddUint64(&amp;amp;c.messageCount, 1)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PutMessage&lt;/code&gt;判断当前Channel是否已经被销毁，若未销毁，则调用&lt;code&gt;put&lt;/code&gt;函数进行处理，最后，自增消息计数器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) put(m *Message) error {
	select {
	case c.memoryMsgChan &amp;lt;- m:
	default:
		b := bufferPoolGet()
		err := writeMessageToBackend(b, m, c.backend)
		bufferPoolPut(b)
		c.ctx.nsqd.SetHealth(err)
		if err != nil {
			c.ctx.nsqd.logf(&amp;quot;CHANNEL(%s) ERROR: failed to write message to backend - %s&amp;quot;,
				c.name, err)
			return err
		}
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel的&lt;code&gt;put&lt;/code&gt;函数与Topic的同名函数相似，可以参考Topic。&lt;/p&gt;

&lt;h1 id=&#34;channel对消息的处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;Channel对消息的处理&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// messagePump reads messages from either memory or backend and sends
// messages to clients over a go chan
func (c *Channel) messagePump() {
	var msg *Message
	var buf []byte
	var err error

	for {
		// do an extra check for closed exit before we select on all the memory/backend/exitChan
		// this solves the case where we are closed and something else is draining clientMsgChan into
		// backend. we don&#39;t want to reverse that
		if atomic.LoadInt32(&amp;amp;c.exitFlag) == 1 {
			goto exit
		}

		select {
		case msg = &amp;lt;-c.memoryMsgChan:
		case buf = &amp;lt;-c.backend.ReadChan():
			msg, err = decodeMessage(buf)
			if err != nil {
				c.ctx.nsqd.logf(&amp;quot;ERROR: failed to decode message - %s&amp;quot;, err)
				continue
			}
		case &amp;lt;-c.exitChan:
			goto exit
		}

		msg.Attempts++

		atomic.StoreInt32(&amp;amp;c.bufferedCount, 1)
		c.clientMsgChan &amp;lt;- msg
		atomic.StoreInt32(&amp;amp;c.bufferedCount, 0)
		// the client will call back to mark as in-flight w/ its info
	}

exit:
	c.ctx.nsqd.logf(&amp;quot;CHANNEL(%s): closing ... messagePump&amp;quot;, c.name)
	close(c.clientMsgChan)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入Channel的消息在&lt;code&gt;messagePump&lt;/code&gt;函数中处理，该函数也与Topic的同名函数相似：
消息都从memory和backend两个来源接收，然后解码消息后处理。与Topic不同的是，channel在投递消息前，
会自增&lt;code&gt;msg.Attempts&lt;/code&gt;，该变量用于保存投递尝试的次数。&lt;/p&gt;

&lt;p&gt;在消息投递前会将&lt;code&gt;bufferedCount&lt;/code&gt;置为1，在投递后置为0。该变量在&lt;code&gt;Depth&lt;/code&gt;函数中被调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) Depth() int64 {
	return int64(len(c.memoryMsgChan)) + c.backend.Depth() + int64(atomic.LoadInt32(&amp;amp;c.bufferedCount))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Deepth&lt;/code&gt;函数返回内存，磁盘以及正在投递的消息数量之和，也就是尚未投递成功的消息数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;函数在投递消息时将消息送入&lt;code&gt;clientMsgChan&lt;/code&gt;，随后被&lt;code&gt;nsqd\protocol_v2.go&lt;/code&gt;的&lt;code&gt;messagePump&lt;/code&gt;函数处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// nsqd\protocol_v2.go  messagePump Line 303
case msg, ok := &amp;lt;-clientMsgChan:
    if !ok {
        goto exit
    }

    if sampleRate &amp;gt; 0 &amp;amp;&amp;amp; rand.Int31n(100) &amp;gt; sampleRate {
        continue
    }

    subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)
    client.SendingMessage()
    err = p.SendMessage(client, msg, &amp;amp;buf)
    if err != nil {
        goto exit
    }
    flushed = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在protocolV2的&lt;code&gt;messagePump&lt;/code&gt;函数中，消息被通过投送到相应消费者。
投递时首先调用Channel的&lt;code&gt;StartInFlightTimeout&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) StartInFlightTimeout(msg *Message, clientID int64, timeout time.Duration) error {
	now := time.Now()
	msg.clientID = clientID
	msg.deliveryTS = now
	msg.pri = now.Add(timeout).UnixNano()
	err := c.pushInFlightMessage(msg)
	if err != nil {
		return err
	}
	c.addToInFlightPQ(msg)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数填充消息的消费者ID、投送时间、优先级，然后调用&lt;code&gt;pushInFlightMessage&lt;/code&gt;函数将消息放入&lt;code&gt;inFlightMessages&lt;/code&gt;字典中。
最后调用&lt;code&gt;addToInFlightPQ&lt;/code&gt;将消息放入&lt;code&gt;inFlightPQ&lt;/code&gt;队列中。&lt;/p&gt;

&lt;p&gt;至此，消息投递流程完成，接下来需要等待消费者对投送结果的反馈。消费者通过发送&lt;code&gt;FIN&lt;/code&gt;、&lt;code&gt;REQ&lt;/code&gt;、&lt;code&gt;TOUCH&lt;/code&gt;来回复对消息的处理结果。&lt;/p&gt;

&lt;p&gt;关于TCP protocol相关的内容，在后续博文分析。以下只分析与Channel相关的部分。&lt;/p&gt;

&lt;h1 id=&#34;消息投送结果处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息投送结果处理&lt;/h1&gt;

&lt;h2 id=&#34;消息投送成功的处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息投送成功的处理&lt;/h2&gt;

&lt;p&gt;消费者发送&lt;code&gt;FIN&lt;/code&gt;，表明消息已经被接收并正确处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// FinishMessage successfully discards an in-flight message
func (c *Channel) FinishMessage(clientID int64, id MessageID) error {
	msg, err := c.popInFlightMessage(clientID, id)
	if err != nil {
		return err
	}
	c.removeFromInFlightPQ(msg)
	if c.e2eProcessingLatencyStream != nil {
		c.e2eProcessingLatencyStream.Insert(msg.Timestamp)
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FIN消息在与Channel相关的部分交由&lt;code&gt;FinishMessage&lt;/code&gt;处理。
最后调用&lt;code&gt;addToInFlightPQ&lt;/code&gt;将消息放入&lt;code&gt;inFlightPQ&lt;/code&gt;队列中。
&lt;code&gt;FinishMessage&lt;/code&gt;分别调用&lt;code&gt;popInFlightMessage&lt;/code&gt;和&lt;code&gt;removeFromInFlightPQ&lt;/code&gt;将消息从&lt;code&gt;inFlightMessages&lt;/code&gt;和&lt;code&gt;inFlightPQ&lt;/code&gt;中删除。
最后，统计该消息的投递情况。&lt;/p&gt;

&lt;h2 id=&#34;消息投送失败的处理:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息投送失败的处理&lt;/h2&gt;

&lt;p&gt;客户端发送&lt;code&gt;REQ&lt;/code&gt;，表明消息投递失败，需要再次被投递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RequeueMessage requeues a message based on `time.Duration`, ie:
//
// `timeoutMs` == 0 - requeue a message immediately
// `timeoutMs`  &amp;gt; 0 - asynchronously wait for the specified timeout
//     and requeue a message (aka &amp;quot;deferred requeue&amp;quot;)
//
func (c *Channel) RequeueMessage(clientID int64, id MessageID, timeout time.Duration) error {
	// remove from inflight first
	msg, err := c.popInFlightMessage(clientID, id)
	if err != nil {
		return err
	}
	c.removeFromInFlightPQ(msg)

	if timeout == 0 {
		return c.doRequeue(msg)
	}

	// deferred requeue
	return c.StartDeferredTimeout(msg, timeout)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel在&lt;code&gt;RequeueMessage&lt;/code&gt;函数对消息投递失败进行处理。该函数将消息从&lt;code&gt;inFlightMessages&lt;/code&gt;和&lt;code&gt;inFlightPQ&lt;/code&gt;中删除，
随后进行重新投递。&lt;/p&gt;

&lt;p&gt;发送&lt;code&gt;REQ&lt;/code&gt;时有一个附加参数timeout，该值为0时表示立即重新投递，大于0时表示等待timeout时间之后投递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// doRequeue performs the low level operations to requeue a message
func (c *Channel) doRequeue(m *Message) error {
	c.RLock()
	defer c.RUnlock()
	if atomic.LoadInt32(&amp;amp;c.exitFlag) == 1 {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}
	err := c.put(m)
	if err != nil {
		return err
	}
	atomic.AddUint64(&amp;amp;c.requeueCount, 1)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立即投递使用&lt;code&gt;doRequeue&lt;/code&gt;函数，该函数简单地调用&lt;code&gt;put&lt;/code&gt;函数重新进行消息的投递，并自增&lt;code&gt;requeueCount&lt;/code&gt;，该变量在统计消息投递情况时用到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Channel) StartDeferredTimeout(msg *Message, timeout time.Duration) error {
	absTs := time.Now().Add(timeout).UnixNano()
	item := &amp;amp;pqueue.Item{Value: msg, Priority: absTs}
	err := c.pushDeferredMessage(item)
	if err != nil {
		return err
	}
	c.addToDeferredPQ(item)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果timeout大于0，则调用&lt;code&gt;StartDeferredTimeout&lt;/code&gt;进行延迟投递。
首先计算延迟投递的时间点，然后调用&lt;code&gt;pushDeferredMessage&lt;/code&gt;将消息加入&lt;code&gt;deferredMessage&lt;/code&gt;字典，
最后将消息放入&lt;code&gt;deferredPQ&lt;/code&gt;队列。延迟投递的消息会被专门的worker扫描并在延迟投递的时间点后进行投递。
需要注意的是，立即重新投递的消息不会进入&lt;code&gt;deferredPQ&lt;/code&gt;队列。&lt;/p&gt;

&lt;h2 id=&#34;消息的超时值的重置:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息的超时值的重置&lt;/h2&gt;

&lt;p&gt;消费者发送&lt;code&gt;TOUCH&lt;/code&gt;，表明该消息的超时值需要被重置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// TouchMessage resets the timeout for an in-flight message
func (c *Channel) TouchMessage(clientID int64, id MessageID, clientMsgTimeout time.Duration) error {
	msg, err := c.popInFlightMessage(clientID, id)
	if err != nil {
		return err
	}
	c.removeFromInFlightPQ(msg)

	newTimeout := time.Now().Add(clientMsgTimeout)
	if newTimeout.Sub(msg.deliveryTS) &amp;gt;=
		c.ctx.nsqd.getOpts().MaxMsgTimeout {
		// we would have gone over, set to the max
		newTimeout = msg.deliveryTS.Add(c.ctx.nsqd.getOpts().MaxMsgTimeout)
	}

	msg.pri = newTimeout.UnixNano()
	err = c.pushInFlightMessage(msg)
	if err != nil {
		return err
	}
	c.addToInFlightPQ(msg)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个过程比较简单，从&lt;code&gt;inFlightPQ&lt;/code&gt;中取出消息，设置新的超时值后重新放入队列，新的超时值由当前时间、
客户端通过&lt;code&gt;IDENTIFY&lt;/code&gt;设置的超时值、配置中允许的最大超时值&lt;code&gt;MaxMsgTimeout&lt;/code&gt;共同决定。&lt;/p&gt;

&lt;h1 id=&#34;消息的超时和延迟投递:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;消息的超时和延迟投递&lt;/h1&gt;

&lt;p&gt;消息超时和延迟投递的处理流程层次比较多：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;n.waitGroup.Wrap(func() { n.queueScanLoop() })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是在&lt;code&gt;nsqd\nsqd.go&lt;/code&gt;中启动的处理延迟消息的goroutine。该goroutine执行&lt;code&gt;queueScanLoop&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// queueScanLoop runs in a single goroutine to process in-flight and deferred
// priority queues. It manages a pool of queueScanWorker (configurable max of
// QueueScanWorkerPoolMax (default: 4)) that process channels concurrently.
//
// It copies Redis&#39;s probabilistic expiration algorithm: it wakes up every
// QueueScanInterval (default: 100ms) to select a random QueueScanSelectionCount
// (default: 20) channels from a locally cached list (refreshed every
// QueueScanRefreshInterval (default: 5s)).
//
// If either of the queues had work to do the channel is considered &amp;quot;dirty&amp;quot;.
//
// If QueueScanDirtyPercent (default: 25%) of the selected channels were dirty,
// the loop continues without sleep.
func (n *NSQD) queueScanLoop() {
	workCh := make(chan *Channel, n.getOpts().QueueScanSelectionCount)
	responseCh := make(chan bool, n.getOpts().QueueScanSelectionCount)
	closeCh := make(chan int)

	workTicker := time.NewTicker(n.getOpts().QueueScanInterval)
	refreshTicker := time.NewTicker(n.getOpts().QueueScanRefreshInterval)

	channels := n.channels()
	n.resizePool(len(channels), workCh, responseCh, closeCh)

	for {
		select {
		case &amp;lt;-workTicker.C:
			if len(channels) == 0 {
				continue
			}
		case &amp;lt;-refreshTicker.C:
			channels = n.channels()
			n.resizePool(len(channels), workCh, responseCh, closeCh)
			continue
		case &amp;lt;-n.exitChan:
			goto exit
		}

		num := n.getOpts().QueueScanSelectionCount
		if num &amp;gt; len(channels) {
			num = len(channels)
		}

	loop:
		for _, i := range util.UniqRands(num, len(channels)) {
			workCh &amp;lt;- channels[i]
		}

		numDirty := 0
		for i := 0; i &amp;lt; num; i++ {
			if &amp;lt;-responseCh {
				numDirty++
			}
		}

		if float64(numDirty)/float64(num) &amp;gt; n.getOpts().QueueScanDirtyPercent {
			goto loop
		}
	}

exit:
	n.logf(&amp;quot;QUEUESCAN: closing&amp;quot;)
	close(closeCh)
	workTicker.Stop()
	refreshTicker.Stop()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数使用若干个worker来扫描并处理当前在投递中以及等待重新投递的消息。worker的个数由配置和当前Channel数量共同决定。
首先，初始化3个gochannel：workCh、responseCh、closeCh，分别控制worker的输入、输出和销毁。&lt;/p&gt;

&lt;p&gt;然后获取当前的Channel集合，并且调用&lt;code&gt;resizePool&lt;/code&gt;函数来启动指定数量的worker。&lt;/p&gt;

&lt;p&gt;最后进入扫描的循环。在循环中，等待两个定时器，&lt;code&gt;workTicker&lt;/code&gt;和&lt;code&gt;refreshTicker&lt;/code&gt;，
定时时间分别由由配置中的&lt;code&gt;QueueScanInterval&lt;/code&gt;和&lt;code&gt;QueueScanRefreshInterval&lt;/code&gt;决定。
这种由等待定时器触发的循环避免了函数持续的执行影响性能，而Golang的特性使得这种机制在写法上非常简洁。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;workTicker&lt;/code&gt;定时器触发扫描流程。
nsqd采用了Redis的probabilistic expiration算法来进行扫描。首先从所有Channel中随机选取部分Channel，然后遍历被选取的Channel，投到&lt;code&gt;workerChan&lt;/code&gt;中，并且等待反馈结果，
结果有两种，dirty和非dirty，如果dirty的比例超过配置中设定的&lt;code&gt;QueueScanDirtyPercent&lt;/code&gt;，那么不进入休眠，
继续扫描，如果比例较低，则重新等待定时器触发下一轮扫描。这种机制可以在保证处理延时较低的情况下减少对CPU资源的浪费。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refreshTicker&lt;/code&gt;定时器触发更新Channel列表流程。
这个流程比较简单，先获取一次Channel列表，
再调用&lt;code&gt;resizePool&lt;/code&gt;重新分配worker。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来再看看&lt;code&gt;resizePool&lt;/code&gt;的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// resizePool adjusts the size of the pool of queueScanWorker goroutines
//
// 	1 &amp;lt;= pool &amp;lt;= min(num * 0.25, QueueScanWorkerPoolMax)
//
func (n *NSQD) resizePool(num int, workCh chan *Channel, responseCh chan bool, closeCh chan int) {
	idealPoolSize := int(float64(num) * 0.25)
	if idealPoolSize &amp;lt; 1 {
		idealPoolSize = 1
	} else if idealPoolSize &amp;gt; n.getOpts().QueueScanWorkerPoolMax {
		idealPoolSize = n.getOpts().QueueScanWorkerPoolMax
	}
	for {
		if idealPoolSize == n.poolSize {
			break
		} else if idealPoolSize &amp;lt; n.poolSize {
			// contract
			closeCh &amp;lt;- 1
			n.poolSize--
		} else {
			// expand
			n.waitGroup.Wrap(func() {
				n.queueScanWorker(workCh, responseCh, closeCh)
			})
			n.poolSize++
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个部分比较简单。注意一点，当需要的worker数量超过之前分配的数量时，通过向&lt;code&gt;closeCh&lt;/code&gt;投递消息使多余的worker销毁，
如果需要的数量比之前的多，则通过&lt;code&gt;queueScanWorker&lt;/code&gt;创建新的worker。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// queueScanWorker receives work (in the form of a channel) from queueScanLoop
// and processes the deferred and in-flight queues
func (n *NSQD) queueScanWorker(workCh chan *Channel, responseCh chan bool, closeCh chan int) {
	for {
		select {
		case c := &amp;lt;-workCh:
			now := time.Now().UnixNano()
			dirty := false
			if c.processInFlightQueue(now) {
				dirty = true
			}
			if c.processDeferredQueue(now) {
				dirty = true
			}
			responseCh &amp;lt;- dirty
		case &amp;lt;-closeCh:
			return
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;queueScanWorker&lt;/code&gt;接收&lt;code&gt;workCh&lt;/code&gt;发来的消息，处理，并且通过&lt;code&gt;responseCh&lt;/code&gt;反馈消息。收到&lt;code&gt;closeCh&lt;/code&gt;时则关闭。
由于所有worker都监听相同的&lt;code&gt;closeCh&lt;/code&gt;，所以当向&lt;code&gt;closeCh&lt;/code&gt;发送消息时，随机关闭一个worker。
且由于&lt;code&gt;workCh&lt;/code&gt;和&lt;code&gt;closeCh&lt;/code&gt;的监听是串行的，所以不存在任务处理到一半时被关闭的可能。
这也是nsq中优雅关闭gochannel的的一个例子。&lt;/p&gt;

&lt;p&gt;worker处理两件事：&lt;/p&gt;

&lt;p&gt;一是处理inFlight消息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func (c *Channel) processInFlightQueue(t int64) bool {
	c.exitMutex.RLock()
	defer c.exitMutex.RUnlock()

	if c.Exiting() {
		return false
	}

	dirty := false
	for {
		c.inFlightMutex.Lock()
		msg, _ := c.inFlightPQ.PeekAndShift(t)
		c.inFlightMutex.Unlock()

		if msg == nil {
			goto exit
		}
		dirty = true

		_, err := c.popInFlightMessage(msg.clientID, msg.ID)
		if err != nil {
			goto exit
		}
		atomic.AddUint64(&amp;amp;c.timeoutCount, 1)
		c.RLock()
		client, ok := c.clients[msg.clientID]
		c.RUnlock()
		if ok {
			client.TimedOutMessage()
		}
		c.doRequeue(msg)
	}

exit:
	return dirty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;processInFlightQueue&lt;/code&gt;取出&lt;code&gt;inFlightPQ&lt;/code&gt;顶部的消息，如果当前消息已经超时，则将消息从队列中移除，并返回消息。
由于队列是优先级队列，所以如果&lt;code&gt;processInFlightQueue&lt;/code&gt;取出的消息为空，则不需要再往后取了，直接返回false表示当前非dirty状态。
如果取到了消息，则说明该消息投递超时，需要把消息传入&lt;code&gt;doRequeue&lt;/code&gt;立即重新投递。&lt;/p&gt;

&lt;p&gt;二是处理deferred消息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func (c *Channel) processDeferredQueue(t int64) bool {
	c.exitMutex.RLock()
	defer c.exitMutex.RUnlock()

	if c.Exiting() {
		return false
	}

	dirty := false
	for {
		c.deferredMutex.Lock()
		item, _ := c.deferredPQ.PeekAndShift(t)
		c.deferredMutex.Unlock()

		if item == nil {
			goto exit
		}
		dirty = true

		msg := item.Value.(*Message)
		_, err := c.popDeferredMessage(msg.ID)
		if err != nil {
			goto exit
		}
		c.doRequeue(msg)
	}

exit:
	return dirty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该处理流程与处理inFlight基本相同，不再详述。&lt;/p&gt;

&lt;h1 id=&#34;其他操作:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;其他操作&lt;/h1&gt;

&lt;p&gt;Channel中还有些其他函数如
&lt;code&gt;Exiting&lt;/code&gt;、&lt;code&gt;Delete&lt;/code&gt;、&lt;code&gt;Close&lt;/code&gt;、&lt;code&gt;exit&lt;/code&gt;、&lt;code&gt;Empty&lt;/code&gt;、&lt;code&gt;flush&lt;/code&gt;、&lt;code&gt;Pause&lt;/code&gt;、&lt;code&gt;UnPause&lt;/code&gt;、&lt;code&gt;doPause&lt;/code&gt;
等与Topic中很接近，不再详述。&lt;code&gt;AddClient&lt;/code&gt;和&lt;code&gt;RemoveClient&lt;/code&gt;将在分析Client时讨论。&lt;/p&gt;

&lt;h1 id=&#34;总结:b8a36880ebd977f3b5cea4ba6491a0d5&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;Topic/Channel是发布/订阅模型的一种实现。Topic对应于发布，Channel对应于订阅。
消费者通过在Topic下生成不同的Channel来接收来自该Topic的消息。
通过生成相同的Channel来实现消费者负载均衡。&lt;/p&gt;

&lt;p&gt;Channel本身在投递消息给消费者时维护两个队列，一个是inFlight队列，该队列存储正在投递，但还没被标记为投递成功的消息。
另一个是deferred队列，用来存储需要被延时投递的消息。&lt;/p&gt;

&lt;p&gt;inFlight队列中消息可能因为投递超时而失败，deferred队列中的消息需要在到达指定时间后进行重新投递。
如果为两个队列中的每个消息都分别指定定时器，无疑是非常消耗资源的。因此nsq采用定时扫描队列的做法。
在扫描时采用多个worker分别处理。这种类似多线程的处理方式提高了处理效率。
nsq在扫描策略上使用了Redis的probabilistic expiration算法，同时动态调整worker的数量，
这些优化平衡了效率和资源占用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nsq源码阅读笔记之nsqd（三）——diskQueue</title>
      <link>http://blog.rayxxzhang.com/2015/11/27/nsqd_source_3_diskqueue/</link>
      <pubDate>Fri, 27 Nov 2015 16:14:26 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/11/27/nsqd_source_3_diskqueue/</guid>
      <description>

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;是&lt;code&gt;backendQueue&lt;/code&gt;接口的一个实现。&lt;code&gt;backendQueue&lt;/code&gt;的作用是在实现在内存go channel缓冲区满的情况下对消息的处理的对象。
除了&lt;code&gt;diskQueue&lt;/code&gt;外还有&lt;code&gt;dummyBackendQueue&lt;/code&gt;实现了&lt;code&gt;backendQueue&lt;/code&gt;接口。&lt;/p&gt;

&lt;p&gt;对于临时（#ephemeral结尾）Topic/Channel，在创建时会使用&lt;code&gt;dummyBackendQueue&lt;/code&gt;初始化&lt;code&gt;backend&lt;/code&gt;，
&lt;code&gt;dummyBackendQueue&lt;/code&gt;只是为了统一临时和非临时Topic/Channel而写的，它只是实现了接口，不做任何实质上的操作，
因此在内存缓冲区满时直接丢弃消息。这也是临时Topic/Channel和非临时的一个比较大的差别。
每个非临时Topic/Channel，创建的时候使用&lt;code&gt;diskQueue&lt;/code&gt;初始化&lt;code&gt;backend&lt;/code&gt;，&lt;code&gt;diskQueue&lt;/code&gt;的功能是将消息写入磁盘进行持久化，
并在需要时从中取出消息重新向客户端投递。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;的实现在&lt;code&gt;nsqd/disk_queue.go&lt;/code&gt;中。&lt;strong&gt;需要注意一点&lt;/strong&gt;，查找&lt;code&gt;diskQueue&lt;/code&gt;中的函数的调用可能不会返回正确的结果，
因为&lt;code&gt;diskQueue&lt;/code&gt;对外是以&lt;code&gt;backendQueue&lt;/code&gt;形式存在，因此查找&lt;code&gt;diskQueue&lt;/code&gt;的函数的调用情况时应当查找&lt;code&gt;backendQueue&lt;/code&gt;中相应函数的调用。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-的创建和初始化:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的创建和初始化&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// newDiskQueue instantiates a new instance of diskQueue, retrieving metadata
// from the filesystem and starting the read ahead goroutine
func newDiskQueue(name string, dataPath string, maxBytesPerFile int64,
	minMsgSize int32, maxMsgSize int32,
	syncEvery int64, syncTimeout time.Duration,
	logger logger) BackendQueue {
	d := diskQueue{
		name:              name,
		dataPath:          dataPath,
		maxBytesPerFile:   maxBytesPerFile,
		minMsgSize:        minMsgSize,
		maxMsgSize:        maxMsgSize,
		readChan:          make(chan []byte),
		writeChan:         make(chan []byte),
		writeResponseChan: make(chan error),
		emptyChan:         make(chan int),
		emptyResponseChan: make(chan error),
		exitChan:          make(chan int),
		exitSyncChan:      make(chan int),
		syncEvery:         syncEvery,
		syncTimeout:       syncTimeout,
		logger:            logger,
	}

	// no need to lock here, nothing else could possibly be touching this instance
	err := d.retrieveMetaData()
	if err != nil &amp;amp;&amp;amp; !os.IsNotExist(err) {
		d.logf(&amp;quot;ERROR: diskqueue(%s) failed to retrieveMetaData - %s&amp;quot;, d.name, err)
	}

	go d.ioLoop()

	return &amp;amp;d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;的获得是通过&lt;code&gt;newDiskQueue&lt;/code&gt;，该函数比较简单，通过传入的参数创建一个&lt;code&gt;dispQueue&lt;/code&gt;，
然后通过&lt;code&gt;retrieveMetaData&lt;/code&gt;函数获取之前与该&lt;code&gt;diskQueue&lt;/code&gt;相关联的Topic/Channel已经持久化的信息。最后启动&lt;code&gt;ioLoop&lt;/code&gt;循环处理消息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// retrieveMetaData initializes state from the filesystem
func (d *diskQueue) retrieveMetaData() error {
	var f *os.File
	var err error

	fileName := d.metaDataFileName()
	f, err = os.OpenFile(fileName, os.O_RDONLY, 0600)
	if err != nil {
		return err
	}
	defer f.Close()

	var depth int64
	_, err = fmt.Fscanf(f, &amp;quot;%d\n%d,%d\n%d,%d\n&amp;quot;,
		&amp;amp;depth,
		&amp;amp;d.readFileNum, &amp;amp;d.readPos,
		&amp;amp;d.writeFileNum, &amp;amp;d.writePos)
	if err != nil {
		return err
	}
	atomic.StoreInt64(&amp;amp;d.depth, depth)
	d.nextReadFileNum = d.readFileNum
	d.nextReadPos = d.readPos

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;retrieveMetaData&lt;/code&gt;函数从磁盘中恢复&lt;code&gt;diskQueue&lt;/code&gt;的状态。&lt;code&gt;diskQueue&lt;/code&gt;会定时将自己的状态备份到文件中，
文件名由&lt;code&gt;metaDataFileName&lt;/code&gt;函数确定。&lt;code&gt;retrieveMetaData&lt;/code&gt;函数同样通过&lt;code&gt;metaDataFileName&lt;/code&gt;函数获得保存状态的文件名并打开。
该文件只有三行，格式为&lt;code&gt;%d\n%d,%d\n%d,%d\n&lt;/code&gt;，第一行保存着该&lt;code&gt;diskQueue&lt;/code&gt;中消息的数量（&lt;code&gt;depth&lt;/code&gt;），
第二行保存&lt;code&gt;readFileNum&lt;/code&gt;和&lt;code&gt;readPos&lt;/code&gt;，第三行保存&lt;code&gt;writeFileNum&lt;/code&gt;和&lt;code&gt;writePos&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里不太理解的一个地方是&lt;code&gt;d.depth&lt;/code&gt;通过一个临时变量去获取然后通过&lt;code&gt;atomic.StoreInt64&lt;/code&gt;保存。个人觉得没有必要这么做。
当然作者在&lt;a href=&#34;https://github.com/nsqio/nsq/pull/203#discussion-diff-4280536&#34;&gt;nsqd: diskqueue corruption and depth accounting&lt;/a&gt;这个Pull Request中也提到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I dont believe that this should be strictly necessary because &lt;code&gt;retrieveMetaData&lt;/code&gt; is only ever called in &lt;code&gt;NewDiskQueue&lt;/code&gt; and the &lt;code&gt;ioLoop&lt;/code&gt; goroutine is launched after that call (which according to the go memory model is safe).&lt;/p&gt;

&lt;p&gt;However, I&amp;rsquo;m not 100% sure about interactions between the go memory model, go-routines, and the combined use of atomic and non-atomic operations (which is what this was relying on before this change&amp;hellip; i.e. this was the only mutation of &lt;code&gt;d.depth&lt;/code&gt; that was &lt;strong&gt;not&lt;/strong&gt; using atomic ops).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，这只是个比较保险的做法，并不一定意味着直接保存到&lt;code&gt;d.depth&lt;/code&gt;就不安全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// persistMetaData atomically writes state to the filesystem
func (d *diskQueue) persistMetaData() error {
	var f *os.File
	var err error

	fileName := d.metaDataFileName()
	tmpFileName := fmt.Sprintf(&amp;quot;%s.%d.tmp&amp;quot;, fileName, rand.Int())

	// write to tmp file
	f, err = os.OpenFile(tmpFileName, os.O_RDWR|os.O_CREATE, 0600)
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(f, &amp;quot;%d\n%d,%d\n%d,%d\n&amp;quot;,
		atomic.LoadInt64(&amp;amp;d.depth),
		d.readFileNum, d.readPos,
		d.writeFileNum, d.writePos)
	if err != nil {
		f.Close()
		return err
	}
	f.Sync()
	f.Close()

	// atomically rename
	return atomicRename(tmpFileName, fileName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;retrieveMetaData&lt;/code&gt;相对应的是&lt;code&gt;persistMetaData&lt;/code&gt;函数，这个函数将运行时的元数据保存到文件用于下次重新构建&lt;code&gt;diskQueue&lt;/code&gt;时的恢复。
逻辑基本与&lt;code&gt;retrieveMetaData&lt;/code&gt;，此处不再赘述。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-的消息循环:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的消息循环&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ioLoop provides the backend for exposing a go channel (via ReadChan())
// in support of multiple concurrent queue consumers
//
// it works by looping and branching based on whether or not the queue has data
// to read and blocking until data is either read or written over the appropriate
// go channels
//
// conveniently this also means that we&#39;re asynchronously reading from the filesystem
func (d *diskQueue) ioLoop() {
	var dataRead []byte
	var err error
	var count int64
	var r chan []byte

	syncTicker := time.NewTicker(d.syncTimeout)

	for {
		// dont sync all the time :)
		if count == d.syncEvery {
			count = 0
			d.needSync = true
		}

		if d.needSync {
			err = d.sync()
			if err != nil {
				d.logf(&amp;quot;ERROR: diskqueue(%s) failed to sync - %s&amp;quot;, d.name, err)
			}
		}

		if (d.readFileNum &amp;lt; d.writeFileNum) || (d.readPos &amp;lt; d.writePos) {
			if d.nextReadPos == d.readPos {
				dataRead, err = d.readOne()
				if err != nil {
					d.logf(&amp;quot;ERROR: reading from diskqueue(%s) at %d of %s - %s&amp;quot;,
						d.name, d.readPos, d.fileName(d.readFileNum), err)
					d.handleReadError()
					continue
				}
			}
			r = d.readChan
		} else {
			r = nil
		}

		select {
		// the Go channel spec dictates that nil channel operations (read or write)
		// in a select are skipped, we set r to d.readChan only when there is data to read
		case r &amp;lt;- dataRead:
			// moveForward sets needSync flag if a file is removed
			d.moveForward()
		case &amp;lt;-d.emptyChan:
			d.emptyResponseChan &amp;lt;- d.deleteAllFiles()
			count = 0
		case dataWrite := &amp;lt;-d.writeChan:
			count++
			d.writeResponseChan &amp;lt;- d.writeOne(dataWrite)
		case &amp;lt;-syncTicker.C:
			if count &amp;gt; 0 {
				count = 0
				d.needSync = true
			}
		case &amp;lt;-d.exitChan:
			goto exit
		}
	}

exit:
	d.logf(&amp;quot;DISKQUEUE(%s): closing ... ioLoop&amp;quot;, d.name)
	syncTicker.Stop()
	d.exitSyncChan &amp;lt;- 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ioLoop&lt;/code&gt;函数实现了&lt;code&gt;diskQueue&lt;/code&gt;的消息循环，&lt;code&gt;diskQueue&lt;/code&gt;的定时操作和读写操作的核心都在这个函数中完成。&lt;/p&gt;

&lt;p&gt;函数首先使用&lt;code&gt;time.NewTicker(d.syncTimeout)&lt;/code&gt;定义了&lt;code&gt;syncTicker&lt;/code&gt;变量，&lt;code&gt;syncTicker&lt;/code&gt;的类型是&lt;code&gt;time.Ticker&lt;/code&gt;，
每隔&lt;code&gt;d.syncTimeout&lt;/code&gt;时间就会在&lt;code&gt;syncTicker.C&lt;/code&gt;这个go channel产生一个消息。
通过select &lt;code&gt;syncTicker.C&lt;/code&gt;能实现至多&lt;code&gt;d.syncTimeout&lt;/code&gt;时间就跳出select块一次，这种方式相当于一个延时的&lt;code&gt;default&lt;/code&gt;子句。
在&lt;code&gt;ioLoop&lt;/code&gt;中，通过这种方式，就能在一个goroutine中既实现消息的接收又实现定时任务（跳出select后执行定时任务，然后在进入select）。
有点类似于定时的轮询。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ioLoop&lt;/code&gt;的定时任务是调用&lt;code&gt;sync&lt;/code&gt;函数刷新文件，防止突然结束程序后内存中的内容未被提交到磁盘，导致内容丢失。
控制是否需要同步的变量是&lt;code&gt;d.needSync&lt;/code&gt;，该变量在一次&lt;code&gt;sync&lt;/code&gt;后会被置为&lt;code&gt;false&lt;/code&gt;，在许多需要刷新文件的地方会被置为&lt;code&gt;true&lt;/code&gt;。
在&lt;code&gt;ioLoop&lt;/code&gt;中，&lt;code&gt;d.needSync&lt;/code&gt;变量还跟刷新计数器&lt;code&gt;count&lt;/code&gt;变量有关，&lt;code&gt;count&lt;/code&gt;值的变化规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一次消息循环中，有写入操作，那么&lt;code&gt;count&lt;/code&gt;就会被自增。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;count&lt;/code&gt;达到&lt;code&gt;d.syncEvery&lt;/code&gt;时，会将&lt;code&gt;count&lt;/code&gt;重置为0并且将&lt;code&gt;d.needSync&lt;/code&gt;置为&lt;code&gt;true&lt;/code&gt;，随后进行文件的刷新。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;emptyChan&lt;/code&gt;收到消息时，&lt;code&gt;count&lt;/code&gt;会被重置为0，因为文件已经被删除了，所有要重置刷新计数器。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;syncTicker.C&lt;/code&gt;收到消息后，会将&lt;code&gt;count&lt;/code&gt;重置为0，并且将&lt;code&gt;d.needSync&lt;/code&gt;置为&lt;code&gt;true&lt;/code&gt;。也就是至多&lt;code&gt;d.syncTimeout&lt;/code&gt;时间刷新一次文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;ioLoop&lt;/code&gt;还定时检测当前是否有数据需要被读取，如果&lt;code&gt;(d.readFileNum &amp;lt; d.writeFileNum) || (d.readPos &amp;lt; d.writePos)&lt;/code&gt;
和`&lt;code&gt;d.nextReadPos == d.readPos&lt;/code&gt;这两个条件成立，则执行&lt;code&gt;d.readOne()&lt;/code&gt;并将结果放入&lt;code&gt;dataRead&lt;/code&gt;中，然后设置&lt;code&gt;r&lt;/code&gt;为&lt;code&gt;d.readChan&lt;/code&gt;。
如果条件不成立，则将&lt;code&gt;r&lt;/code&gt;置为空值&lt;code&gt;nil&lt;/code&gt;。随后的select语句中有&lt;code&gt;case r &amp;lt;- dataRead:&lt;/code&gt;这样一个分支，在注释中作者写了这是一个Golang的特性，
即：如果&lt;code&gt;r&lt;/code&gt;不为空，则会将&lt;code&gt;dataRead&lt;/code&gt;送入go channel。进入&lt;code&gt;d.readChan&lt;/code&gt;的消息通过&lt;code&gt;ReadChan&lt;/code&gt;函数向外暴露，最终被Topic/Channel的消息循环读取。
而如果&lt;code&gt;r&lt;/code&gt;为空，则这个分支会被跳过。这个特性的使用统一了select的逻辑，简化了当数据为空时的判断。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-的写操作:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的写操作&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Put writes a []byte to the queue
func (d *diskQueue) Put(data []byte) error {
	d.RLock()
	defer d.RUnlock()

	if d.exitFlag == 1 {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}

	d.writeChan &amp;lt;- data
	return &amp;lt;-d.writeResponseChan
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写操作的对外接口是&lt;code&gt;Put&lt;/code&gt;函数，该函数比较简单，加锁，并且将数据放入&lt;code&gt;d.writeChan&lt;/code&gt;，等待&lt;code&gt;d.writeResponseChan&lt;/code&gt;的结果后返回。
&lt;code&gt;d.writeChan&lt;/code&gt;的接收在&lt;code&gt;ioLoop&lt;/code&gt;中select的一个分支，处理时调用&lt;code&gt;writeOne&lt;/code&gt;函数，并将处理结果放入&lt;code&gt;d.writeResponseChan&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// writeOne performs a low level filesystem write for a single []byte
// while advancing write positions and rolling files, if necessary
func (d *diskQueue) writeOne(data []byte) error {
	var err error

	if d.writeFile == nil {
		curFileName := d.fileName(d.writeFileNum)
		d.writeFile, err = os.OpenFile(curFileName, os.O_RDWR|os.O_CREATE, 0600)
		if err != nil {
			return err
		}

		d.logf(&amp;quot;DISKQUEUE(%s): writeOne() opened %s&amp;quot;, d.name, curFileName)

		if d.writePos &amp;gt; 0 {
			_, err = d.writeFile.Seek(d.writePos, 0)
			if err != nil {
				d.writeFile.Close()
				d.writeFile = nil
				return err
			}
		}
	}

	dataLen := int32(len(data))

	if dataLen &amp;lt; d.minMsgSize || dataLen &amp;gt; d.maxMsgSize {
		return fmt.Errorf(&amp;quot;invalid message write size (%d) maxMsgSize=%d&amp;quot;, dataLen, d.maxMsgSize)
	}

	d.writeBuf.Reset()
	err = binary.Write(&amp;amp;d.writeBuf, binary.BigEndian, dataLen)
	if err != nil {
		return err
	}

	_, err = d.writeBuf.Write(data)
	if err != nil {
		return err
	}

	// only write to the file once
	_, err = d.writeFile.Write(d.writeBuf.Bytes())
	if err != nil {
		d.writeFile.Close()
		d.writeFile = nil
		return err
	}

	totalBytes := int64(4 + dataLen)
	d.writePos += totalBytes
	atomic.AddInt64(&amp;amp;d.depth, 1)

	if d.writePos &amp;gt; d.maxBytesPerFile {
		d.writeFileNum++
		d.writePos = 0

		// sync every time we start writing to a new file
		err = d.sync()
		if err != nil {
			d.logf(&amp;quot;ERROR: diskqueue(%s) failed to sync - %s&amp;quot;, d.name, err)
		}

		if d.writeFile != nil {
			d.writeFile.Close()
			d.writeFile = nil
		}
	}

	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;writeOne&lt;/code&gt;函数是写操作的最终执行部分，负责将消息写入磁盘。函数逻辑比较简单。消息写入步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;若当前要写的文件不存在，则通过&lt;code&gt;d.fileName(d.writeFileNum)&lt;/code&gt;获得文件名，并创建文件&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;d.writePos&lt;/code&gt;定位本次写的位置&lt;/li&gt;
&lt;li&gt;从要写入的内容得到要写入的长度&lt;/li&gt;
&lt;li&gt;先写入3中计算出的消息长度（4字节），然后写入消息本身&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;d.writePos&lt;/code&gt;后移&lt;code&gt;4 + 消息长度&lt;/code&gt;作为下次写入位置。加4是因为消息长度本身也占4字节。&lt;/li&gt;
&lt;li&gt;判断&lt;code&gt;d.writePos&lt;/code&gt;是否大于每个文件的最大字节数&lt;code&gt;d.maxBytesPerFile&lt;/code&gt;，如果是，则将&lt;code&gt;d.writeFileNum&lt;/code&gt;加1，
并重置&lt;code&gt;d.writePos&lt;/code&gt;。这个操作的目的是为了防止单个文件过大。&lt;/li&gt;
&lt;li&gt;如果下次要写入新的文件，那么需要调用&lt;code&gt;sync&lt;/code&gt;函数对当前文件进行同步。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;diskqueue-的读操作:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;的读操作&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// readOne performs a low level filesystem read for a single []byte
// while advancing read positions and rolling files, if necessary
func (d *diskQueue) readOne() ([]byte, error) {
	var err error
	var msgSize int32

	if d.readFile == nil {
		curFileName := d.fileName(d.readFileNum)
		d.readFile, err = os.OpenFile(curFileName, os.O_RDONLY, 0600)
		if err != nil {
			return nil, err
		}

		d.logf(&amp;quot;DISKQUEUE(%s): readOne() opened %s&amp;quot;, d.name, curFileName)

		if d.readPos &amp;gt; 0 {
			_, err = d.readFile.Seek(d.readPos, 0)
			if err != nil {
				d.readFile.Close()
				d.readFile = nil
				return nil, err
			}
		}

		d.reader = bufio.NewReader(d.readFile)
	}

	err = binary.Read(d.reader, binary.BigEndian, &amp;amp;msgSize)
	if err != nil {
		d.readFile.Close()
		d.readFile = nil
		return nil, err
	}

	if msgSize &amp;lt; d.minMsgSize || msgSize &amp;gt; d.maxMsgSize {
		// this file is corrupt and we have no reasonable guarantee on
		// where a new message should begin
		d.readFile.Close()
		d.readFile = nil
		return nil, fmt.Errorf(&amp;quot;invalid message read size (%d)&amp;quot;, msgSize)
	}

	readBuf := make([]byte, msgSize)
	_, err = io.ReadFull(d.reader, readBuf)
	if err != nil {
		d.readFile.Close()
		d.readFile = nil
		return nil, err
	}

	totalBytes := int64(4 + msgSize)

	// we only advance next* because we have not yet sent this to consumers
	// (where readFileNum, readPos will actually be advanced)
	d.nextReadPos = d.readPos + totalBytes
	d.nextReadFileNum = d.readFileNum

	// TODO: each data file should embed the maxBytesPerFile
	// as the first 8 bytes (at creation time) ensuring that
	// the value can change without affecting runtime
	if d.nextReadPos &amp;gt; d.maxBytesPerFile {
		if d.readFile != nil {
			d.readFile.Close()
			d.readFile = nil
		}

		d.nextReadFileNum++
		d.nextReadPos = 0
	}

	return readBuf, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消息读取对外暴露的是一个go channel，而数据的最终来源是&lt;code&gt;ioLoop&lt;/code&gt;中调用的&lt;code&gt;readOne&lt;/code&gt;函数。&lt;code&gt;readOne&lt;/code&gt;函数逻辑跟&lt;code&gt;writeOne&lt;/code&gt;类似，
只是把写操作换成了读操作，唯一差异较大的地方是&lt;code&gt;d.nextReadPos&lt;/code&gt;和&lt;code&gt;d.nextReadFileNum&lt;/code&gt;这两个变量的使用。&lt;/p&gt;

&lt;p&gt;在写操作时，如果写入成功，则可以直接将写入位置和写入文件更新。但是对于读操作来说，由于读取的目的是为了向客户端投递，
因此无法保证一定能投递成功。因此需要使用next开头的两个变量来保存成功后需要读的位置，如果投递没有成功，
则继续使用当前的读取位置将再一次尝试将消息投递给客户端。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (d *diskQueue) moveForward() {
	oldReadFileNum := d.readFileNum
	d.readFileNum = d.nextReadFileNum
	d.readPos = d.nextReadPos
	depth := atomic.AddInt64(&amp;amp;d.depth, -1)

	// see if we need to clean up the old file
	if oldReadFileNum != d.nextReadFileNum {
		// sync every time we start reading from a new file
		d.needSync = true

		fn := d.fileName(oldReadFileNum)
		err := os.Remove(fn)
		if err != nil {
			d.logf(&amp;quot;ERROR: failed to Remove(%s) - %s&amp;quot;, fn, err)
		}
	}

	d.checkTailCorruption(depth)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当消息投递成功后，则使用&lt;code&gt;moveForward&lt;/code&gt;函数将保存在&lt;code&gt;d.nextReadPos&lt;/code&gt;和&lt;code&gt;d.nextReadFileNum&lt;/code&gt;中的值取出，
赋值给&lt;code&gt;d.readPos&lt;/code&gt;和&lt;code&gt;d.readFileNum&lt;/code&gt;，&lt;code&gt;moveForward&lt;/code&gt;函数还负责清理已经读完的旧文件。最后，调用&lt;code&gt;checkTailCorruption&lt;/code&gt;函数检查文件是否有错，
如果出现错误，则调用&lt;code&gt;skipToNextRWFile&lt;/code&gt;重置读取和写入的文件编号和位置。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-中的其他函数:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;中的其他函数&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;中还有与错误处理相关的&lt;code&gt;handleReadError&lt;/code&gt;，与关闭&lt;code&gt;diskQueue&lt;/code&gt;相关的&lt;code&gt;Close&lt;/code&gt;，&lt;code&gt;Delete&lt;/code&gt;，&lt;code&gt;exit&lt;/code&gt;，&lt;code&gt;Empty&lt;/code&gt;和&lt;code&gt;deleteAllFiles&lt;/code&gt;等，
函数，逻辑较简单，不再专门分析。&lt;/p&gt;

&lt;h1 id=&#34;diskqueue-总结:944b75e8330a31bfc7882b7e80bb7fb5&#34;&gt;&lt;code&gt;diskQueue&lt;/code&gt;总结&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;主要逻辑是对磁盘的读写操作，较为琐碎但没有复杂的架构。
其中消息循环的思路和读写过程周全的考虑都值得学习的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nsq源码阅读笔记之nsqd（二）——Topic</title>
      <link>http://blog.rayxxzhang.com/2015/11/25/nsqd_source_2_topics/</link>
      <pubDate>Wed, 25 Nov 2015 16:09:44 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/11/25/nsqd_source_2_topics/</guid>
      <description>

&lt;p&gt;与&lt;strong&gt;Topic&lt;/strong&gt;相关的代码主要位于&lt;code&gt;nsqd/nsqd.go&lt;/code&gt;, &lt;code&gt;nsqd/topic.go&lt;/code&gt;中。&lt;/p&gt;

&lt;h1 id=&#34;topic的获取:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的获取&lt;/h1&gt;

&lt;p&gt;Topic通过&lt;code&gt;GetTopic&lt;/code&gt;函数获取&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// GetTopic performs a thread safe operation
// to return a pointer to a Topic object (potentially new)
func (n *NSQD) GetTopic(topicName string) *Topic {
	n.Lock()

	t, ok := n.topicMap[topicName]
	if ok {
		n.Unlock()
		return t
	}
	deleteCallback := func(t *Topic) {
		n.DeleteExistingTopic(t.name)
	}
	t = NewTopic(topicName, &amp;amp;context{n}, deleteCallback)
	n.topicMap[topicName] = t

	n.logf(&amp;quot;TOPIC(%s): created&amp;quot;, t.name)

	// release our global nsqd lock, and switch to a more granular topic lock while we init our
	// channels from lookupd. This blocks concurrent PutMessages to this topic.
	t.Lock()
	n.Unlock()

	// if using lookupd, make a blocking call to get the topics, and immediately create them.
	// this makes sure that any message received is buffered to the right channels
	lookupdHTTPAddrs := n.lookupdHTTPAddrs()
	if len(lookupdHTTPAddrs) &amp;gt; 0 {
		channelNames, _ := n.ci.GetLookupdTopicChannels(t.name, lookupdHTTPAddrs)
		for _, channelName := range channelNames {
			if strings.HasSuffix(channelName, &amp;quot;#ephemeral&amp;quot;) {
				// we don&#39;t want to pre-create ephemeral channels
				// because there isn&#39;t a client connected
				continue
			}
			t.getOrCreateChannel(channelName)
		}
	}

	t.Unlock()

	// NOTE: I would prefer for this to only happen in topic.GetChannel() but we&#39;re special
	// casing the code above so that we can control the locks such that it is impossible
	// for a message to be written to a (new) topic while we&#39;re looking up channels
	// from lookupd...
	//
	// update messagePump state
	select {
	case t.channelUpdateChan &amp;lt;- 1:
	case &amp;lt;-t.exitChan:
	}
	return t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GetTopic&lt;/code&gt;函数用于获取topic对象，首先先尝试从&lt;code&gt;topicMap&lt;/code&gt;表中获取，如果指定的topic存在，则直接返回topic对象。&lt;/p&gt;

&lt;p&gt;当topic不存在时需要新建一个topic，加入到&lt;code&gt;topicMap&lt;/code&gt;中，
如果启用了nsqlookupd则需要从&lt;code&gt;lookupd&lt;/code&gt;中获取该topic的所有channel，在去除&lt;code&gt;#ephemeral&lt;/code&gt;结尾的临时channel后加入到topic中。&lt;/p&gt;

&lt;p&gt;其中锁的使用值得学习：在调用完nsqd的变量后转而进行topic操作，这时候程序转而使用topic的小粒度的锁，释放了nsqd全局的大粒度锁，
在保证线程安全的同时减少了效率上的损失。&lt;/p&gt;

&lt;p&gt;在创建新的topic后需要向&lt;code&gt;channelUpdateChan&lt;/code&gt;发送消息来更新topic中的channel，而&lt;code&gt;channelUpdateChan&lt;/code&gt;是一个阻塞的go channel,
所以此处使用了&lt;code&gt;select&lt;/code&gt;，并同时监听了&lt;code&gt;exitChan&lt;/code&gt;。如果此时&lt;code&gt;exitChan&lt;/code&gt;收到信号则可以正常退出&lt;code&gt;select&lt;/code&gt;。
如果没有&lt;code&gt;case &amp;lt;-t.exitChan&lt;/code&gt;这句话，
则可能接收&lt;code&gt;channelUpdateChan&lt;/code&gt;的go channel已经退出，但是发送端却还在阻塞中。当然，可以通过退出主go channel来结束程序，
但这样做可能造成部分析构的代码没有得到执行，而且在部分场景下，
只是程序的一个go channel结束运行（在nsqd的这个例子中是topic被删除）而非整个程序退出。
为了避免这个问题，nsqd许多向go channal发送消息的地方都使用了这种机制。&lt;/p&gt;

&lt;p&gt;以下是这种机制的一个示例，
可以通过&lt;a href=&#34;http://play.golang.org/p/xLaZcgjypS&#34;&gt;The Go Playground&lt;/a&gt;来运行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	workerChan := make(chan string)
	exitChan := make(chan int)
	go func() {
		&amp;lt;-time.After(time.Second * 1)
		select {
		case workerChan &amp;lt;- &amp;quot;Task 1&amp;quot;:
		}
		fmt.Println(&amp;quot;Task 1 exit&amp;quot;)
	}()
	go func() {
		select {
		case workerChan &amp;lt;- &amp;quot;Task 2&amp;quot;:
		case &amp;lt;- exitChan:
		}
		fmt.Println(&amp;quot;Task 2 exit&amp;quot;)
	}()
	
	go func() {
		select {
		case &amp;lt;-time.After(time.Second * 2):
		}
		fmt.Println(&amp;quot;Close exitChan&amp;quot;)
		close(exitChan)
		&amp;lt;-time.After(time.Second * 4)
		close(workerChan)
	}()
	
	&amp;lt;- time.After(time.Second * 3)
	fmt.Println(&amp;quot;Start receive from workerChan&amp;quot;)
	loop:
	for {
		select {
		case i, ok := &amp;lt;-workerChan:
			if ok {
				fmt.Println(&amp;quot;Receive:&amp;quot;, i)
			} else {
				break loop
			}
		
		}
	}
		
	
	&amp;lt;- time.After(time.Second * 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行程序，得到以下运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Close exitChan
Task 2 exit
Start receive from workerChan
Receive: Task 1
Task 1 exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Task1和Task2是两个生产者，它们都向workerChan发送消息，其中Task2立即发送，Task1有一定延时，workerChan是一个阻塞的go channel。
同时，有一个go channel发送结束信号（关闭exitChan）。随后开启消费者，接收workerChan的消息，
Task1和Task2的区别是Task2在select中多了一个对exitChan的监听。&lt;/p&gt;

&lt;p&gt;从结果可以看出，当exitChan被关闭时，Task2结束对workerChan的阻塞，取消了像worker发送信号，同时结束了自身。
而没有监听exitChan的Task1依然在阻塞，直到被读取后才退出。&lt;/p&gt;

&lt;p&gt;示例说明了可以通过对exitChan的使用来结束对阻塞go channel的等待。需要说明的是，在真实场景中，
消费者在发出结束的意图后可能并不会去处理尚未被处理的消息，所以像示例中的Task1是无法正常结束的。&lt;/p&gt;

&lt;h1 id=&#34;topic的创建:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的创建&lt;/h1&gt;

&lt;p&gt;当&lt;code&gt;GetTopic&lt;/code&gt;未在已存在的topic中找到指定topic时，就会使用&lt;code&gt;NewTopic&lt;/code&gt;函数新建一个&lt;code&gt;Topic&lt;/code&gt;对象。
&lt;code&gt;Topic&lt;/code&gt;和&lt;code&gt;NewTopic&lt;/code&gt;都位于&lt;code&gt;nsqd/topic.go&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewTopic(topicName string, ctx *context, deleteCallback func(*Topic)) *Topic {
	t := &amp;amp;Topic{
		name:              topicName,
		channelMap:        make(map[string]*Channel),
		memoryMsgChan:     make(chan *Message, ctx.nsqd.getOpts().MemQueueSize),
		exitChan:          make(chan int),
		channelUpdateChan: make(chan int),
		ctx:               ctx,
		pauseChan:         make(chan bool),
		deleteCallback:    deleteCallback,
	}

	if strings.HasSuffix(topicName, &amp;quot;#ephemeral&amp;quot;) {
		t.ephemeral = true
		t.backend = newDummyBackendQueue()
	} else {
		t.backend = newDiskQueue(topicName,
			ctx.nsqd.getOpts().DataPath,
			ctx.nsqd.getOpts().MaxBytesPerFile,
			int32(minValidMsgLength),
			int32(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,
			ctx.nsqd.getOpts().SyncEvery,
			ctx.nsqd.getOpts().SyncTimeout,
			ctx.nsqd.getOpts().Logger)
	}

	t.waitGroup.Wrap(func() { t.messagePump() })

	t.ctx.nsqd.Notify(t)

	return t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewTopic&lt;/code&gt;函数首先创建了一个&lt;code&gt;Topic&lt;/code&gt;结构，然后判断该topic是不是一个临时topic。topic中有个名为&lt;code&gt;backend&lt;/code&gt;的变量，
其类型为&lt;code&gt;Backend&lt;/code&gt;接口。对于临时topic，
消息只储存在内存中，因此&lt;code&gt;backend&lt;/code&gt;变量使用&lt;code&gt;newDummyBackendQueue&lt;/code&gt;函数初始化。该函数生成一个无任何功能的&lt;code&gt;dummyBackendQueue&lt;/code&gt;结构；
对于永久的topic，&lt;code&gt;backend&lt;/code&gt;使用&lt;code&gt;newDiskQueue&lt;/code&gt;函数返回&lt;code&gt;diskQueue&lt;/code&gt;类型赋值，并开启新的goroutine来进行数据的持久化。
&lt;code&gt;dummyBackendQueue&lt;/code&gt;和&lt;code&gt;diskQueue&lt;/code&gt;都实现了&lt;code&gt;Backend&lt;/code&gt;接口，因此，在之后可以使用&lt;code&gt;backend&lt;/code&gt;统一处理。&lt;/p&gt;

&lt;p&gt;随后，&lt;code&gt;NewTopic&lt;/code&gt;函数开启一个新的goroutine来执行&lt;code&gt;messagePump&lt;/code&gt;函数，该函数负责消息循环，将进入topic中的消息投递到channel中。&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;NewTopic&lt;/code&gt;函数执行&lt;code&gt;t.ctx.nsqd.Notify(t)&lt;/code&gt;，该函数在topic和channel创建、停止的时候调用，
&lt;code&gt;Notify&lt;/code&gt;函数通过执行&lt;code&gt;PersistMetadata&lt;/code&gt;函数，将topic和channel的信息写到文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (n *NSQD) Notify(v interface{}) {
	// since the in-memory metadata is incomplete,
	// should not persist metadata while loading it.
	// nsqd will call `PersistMetadata` it after loading
	persist := atomic.LoadInt32(&amp;amp;n.isLoading) == 0
	n.waitGroup.Wrap(func() {
		// by selecting on exitChan we guarantee that
		// we do not block exit, see issue #123
		select {
		case &amp;lt;-n.exitChan:
		case n.notifyChan &amp;lt;- v:
			if !persist {
				return
			}
			n.Lock()
			err := n.PersistMetadata()
			if err != nil {
				n.logf(&amp;quot;ERROR: failed to persist metadata - %s&amp;quot;, err)
			}
			n.Unlock()
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Notify&lt;/code&gt;函数的实现时，首先考虑了数据持久化的时机，如果当前nsqd尚在初始化，则不需要立即持久化数据，因为nsqd在初始化后会进行一次统一的持久化工作，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Notify&lt;/code&gt;在进行数据持久化的时候采用了异步的方式。使得topic和channel能以同步的方式来调用Nofity而不阻塞。在异步运行的过程中，
通过&lt;code&gt;waitGroup&lt;/code&gt;和监听&lt;code&gt;exitChan&lt;/code&gt;的使用保证了结束程序时goroutine能正常退出。&lt;/p&gt;

&lt;p&gt;在执行持久化之前，&lt;code&gt;case n.notifyChan &amp;lt;- v:&lt;/code&gt;语句向&lt;code&gt;notifyChan&lt;/code&gt;传递消息，触发&lt;code&gt;lookupLoop&lt;/code&gt;函数（&lt;code&gt;nsqd/lookup.go&lt;/code&gt;中）接收&lt;code&gt;notifyChan&lt;/code&gt;消息的部分，
从而实现向&lt;code&gt;loopupd&lt;/code&gt;注册/取消注册响应的topic或channel。&lt;/p&gt;

&lt;h1 id=&#34;消息进入topic:efd667b960aa7ec362edb15e7af0b343&#34;&gt;消息进入topic&lt;/h1&gt;

&lt;p&gt;客户端通过nsqd的HTTP API或TCP API向特定topic发送消息，nsqd的HTTP或TCP模块通过调用对应topic的&lt;code&gt;PutMessage&lt;/code&gt;或&lt;code&gt;PutMessages&lt;/code&gt;函数，
将消息投递到topic中。&lt;code&gt;PutMessage&lt;/code&gt;或&lt;code&gt;PutMessages&lt;/code&gt;函数都通过topic的私有函数&lt;code&gt;put&lt;/code&gt;进行消息的投递，两个函数的区别仅在&lt;code&gt;PutMessage&lt;/code&gt;只调用一次&lt;code&gt;put&lt;/code&gt;，
&lt;code&gt;PutMessages&lt;/code&gt;遍历所有要投递的消息，对每条消息使用&lt;code&gt;put&lt;/code&gt;函数进行投递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) put(m *Message) error {
	select {
	case t.memoryMsgChan &amp;lt;- m:
	default:
		// ...
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;带缓冲的go-channel的特性:efd667b960aa7ec362edb15e7af0b343&#34;&gt;带缓冲的Go channel的特性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;put&lt;/code&gt;函数使用了一个带缓冲的go channel的特性：如果case里的go channel阻塞了，那么就会跳过该case语句，执行default分支。即，如果当前&lt;code&gt;memoryMsgChan&lt;/code&gt;还有足够缓冲空间，
则消息被投入&lt;code&gt;memoryMsgChan&lt;/code&gt;，如果当前&lt;code&gt;memoryMsgChan&lt;/code&gt;的缓冲区已满，则将执行default分支，从而将消息保存到&lt;code&gt;backend&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;对于临时topic，由于&lt;code&gt;backend&lt;/code&gt;不进行任何操作，这就意味着消息在内存的缓存满了之后会被直接丢弃，对于永久的channel，则&lt;code&gt;backend&lt;/code&gt;会将该消息持久化到磁盘的文件中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;put&lt;/code&gt;函数使用了Golang的channel特性，大大简化了实现这个逻辑的代码量，以下通过一个简单的示例看看Golang的带缓冲的channel的这一特性，
示例可以通过&lt;a href=&#34;http://play.golang.org/p/UKc0IUleyU&#34;&gt;The Golang Playground&lt;/a&gt;运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	workerChan := make(chan string, 3)
	worker2Chan := make(chan string)
	exitChan := make(chan bool)
	
	go func() {
		for {
			select {
			case str := &amp;lt;- workerChan:
				fmt.Println(&amp;quot;Worker1 receive &amp;quot;, str)
				&amp;lt;- time.After(time.Second * 1)
			case str := &amp;lt;- worker2Chan:
				fmt.Println(&amp;quot;Worker2 receive &amp;quot;, str)
			case &amp;lt;- exitChan:
				return
			}
		}	
	}()
	go func() {
		&amp;lt;- time.After(time.Second * 1)
		workerChan &amp;lt;- &amp;quot;Task 1&amp;quot;
		workerChan &amp;lt;- &amp;quot;Task 2&amp;quot;
		workerChan &amp;lt;- &amp;quot;Task 3&amp;quot;
		select {
		case workerChan &amp;lt;- &amp;quot;Task 4&amp;quot;:
		case worker2Chan &amp;lt;- &amp;quot;Task 5&amp;quot;:
		default:
			fmt.Println(&amp;quot;Channel queue full&amp;quot;)
		}
	}()
	
	&amp;lt;- time.After(time.Second * 5)
	close(exitChan)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Channel queue full
Worker1 receive  Task 1
Worker1 receive  Task 2
Worker1 receive  Task 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例程序中有3个go channel，&lt;code&gt;workerChan&lt;/code&gt;和&lt;code&gt;worker2Chan&lt;/code&gt;用于处理消息，&lt;code&gt;exitChan&lt;/code&gt;用于程序的退出。
当消费者go channel启动后，启动一个生产者go channel向&lt;code&gt;workerChan&lt;/code&gt;连续发送3个消息，
&lt;code&gt;time.After&lt;/code&gt;模拟了消费者在处理&lt;code&gt;workerChan&lt;/code&gt;的消息时出现的延迟，而&lt;code&gt;workerChan&lt;/code&gt;的缓冲区只有3，
因此当消费者向&lt;code&gt;workerChan&lt;/code&gt;发送第4个消息的时候会被阻塞，从运行结果看，没有消息被投向&lt;code&gt;worker2Chan&lt;/code&gt;，
程序在遇到阻塞时进入了default分支，打印出&lt;code&gt;Channel queue full&lt;/code&gt;。特定场景下合理使用这一特性能够大幅减少程序的复杂度。&lt;/p&gt;

&lt;h2 id=&#34;put-函数对消息的持久化:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;put&lt;/code&gt;函数对消息的持久化&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := bufferPoolGet()
err := writeMessageToBackend(b, m, t.backend)
bufferPoolPut(b)
t.ctx.nsqd.SetHealth(err)
if err != nil {
	t.ctx.nsqd.logf(
		&amp;quot;TOPIC(%s) ERROR: failed to write message to backend - %s&amp;quot;,
		t.name, err)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上部分来自函数的default分支，用于将消息持久化到磁盘文件中，过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;bufferPoolGet&lt;/code&gt;函数从buffer池中获取一个buffer，&lt;code&gt;bufferPoolGet&lt;/code&gt;及以下&lt;code&gt;bufferPoolPut&lt;/code&gt;函数是对&lt;code&gt;sync.Pool&lt;/code&gt;的简单包装。
两个函数位于&lt;code&gt;nsqd/buffer_pool.go&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;writeMessageToBackend&lt;/code&gt;函数将消息写入磁盘。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;bufferPoolPut&lt;/code&gt;函数将buffer归还buffer池。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;SetHealth&lt;/code&gt;函数将&lt;code&gt;writeMessageToBackend&lt;/code&gt;的返回值写入&lt;code&gt;errValue&lt;/code&gt;变量。
该变量衍生出&lt;code&gt;IsHealthy&lt;/code&gt;，&lt;code&gt;GetError&lt;/code&gt;和&lt;code&gt;GetHealth&lt;/code&gt;3个函数，主要用于测试以及从HTTP API获取nsqd的运行情况（是否发生错误）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func writeMessageToBackend(buf *bytes.Buffer, msg *Message, bq BackendQueue) error {
	buf.Reset()
	_, err := msg.WriteTo(buf)
	if err != nil {
		return err
	}
	return bq.Put(buf.Bytes())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;writeMessageToBackend&lt;/code&gt;函数重新初始化缓存，将&lt;code&gt;Message&lt;/code&gt;类型的消息序列化到缓存中，最后将缓存写入&lt;code&gt;backend&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;topic消息循环:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic消息循环&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;函数负责Topic的消息循环，该函数在创建新的topic时通过&lt;code&gt;waitGroup&lt;/code&gt;在新的goroutine中运行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;函数初始化时先获取当前存在的channel数组，设置&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;，随后进入消息循环，
在循环中主要处理四种消息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接收来自&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;两个go channel进入的消息，并向当前的channal数组中的channel进行投递&lt;/li&gt;
&lt;li&gt;处理当前topic下channel的更新&lt;/li&gt;
&lt;li&gt;处理当前topic的暂停和恢复&lt;/li&gt;
&lt;li&gt;监听当前topic的删除&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;消息投递:efd667b960aa7ec362edb15e7af0b343&#34;&gt;消息投递&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case msg = &amp;lt;-memoryMsgChan:
case buf = &amp;lt;-backendChan:
	msg, err = decodeMessage(buf)
	if err != nil {
		t.ctx.nsqd.logf(&amp;quot;ERROR: failed to decode message - %s&amp;quot;, err)
		continue
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个case语句处理进入topic的消息，关于两个go channel的区别会在后续的博客中分析。
从&lt;code&gt;memoryMsgChanbackendChan&lt;/code&gt;读取到的消息是&lt;code&gt;*Message&lt;/code&gt;类型，而从&lt;code&gt;backendChan&lt;/code&gt;读取到的消息是&lt;code&gt;byte&lt;/code&gt;数组的。
因此取出&lt;code&gt;backendChan&lt;/code&gt;的消息后海需要调用&lt;code&gt;decodeMessage&lt;/code&gt;函数对&lt;code&gt;byte&lt;/code&gt;数组进行解码，返回&lt;code&gt;*Message&lt;/code&gt;类型的消息。
二者都保存在&lt;code&gt;msg&lt;/code&gt;变量中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, channel := range chans {
	chanMsg := msg
	// copy the message because each channel
	// needs a unique instance but...
	// fastpath to avoid copy if its the first channel
	// (the topic already created the first copy)
	if i &amp;gt; 0 {
		chanMsg = NewMessage(msg.ID, msg.Body)
		chanMsg.Timestamp = msg.Timestamp
		chanMsg.deferred = msg.deferred
	}
	if chanMsg.deferred != 0 {
		channel.StartDeferredTimeout(chanMsg, chanMsg.deferred)
		continue
	}
	err := channel.PutMessage(chanMsg)
	if err != nil {
		t.ctx.nsqd.logf(
			&amp;quot;TOPIC(%s) ERROR: failed to put msg(%s) to channel(%s) - %s&amp;quot;,
			t.name, msg.ID, channel.name, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后是将消息投到每个channel中，首先先对消息进行复制操作，这里有个优化，对于第一次循环，
直接使用原消息进行发送以减少复制对象的开销，此后的循环将对消息进行复制。对于即时的消息，
直接调用channel的&lt;code&gt;PutMessage&lt;/code&gt;函数进行投递，对于延迟的消息，
调用channel的&lt;code&gt;StartDeferredTimeout&lt;/code&gt;函数进行投递。对于这两个函数的投递细节，后续博文中会详细分析。&lt;/p&gt;

&lt;h2 id=&#34;topic下channel的更新:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic下Channel的更新&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case &amp;lt;-t.channelUpdateChan:
	chans = chans[:0]
	t.RLock()
	for _, c := range t.channelMap {
		chans = append(chans, c)
	}
	t.RUnlock()
	if len(chans) == 0 || t.IsPaused() {
		memoryMsgChan = nil
		backendChan = nil
	} else {
		memoryMsgChan = t.memoryMsgChan
		backendChan = t.backend.ReadChan()
	}
	continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Channel的更新比较简单，从&lt;code&gt;channelMap&lt;/code&gt;中取出每个channel，构成channel的数组以便后续进行消息的投递。
并且根据当前是否有channel以及该topic是否处于暂停状态来决定&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;是否为空。&lt;/p&gt;

&lt;h2 id=&#34;topic的暂停和恢复:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的暂停和恢复&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case pause := &amp;lt;-t.pauseChan:
	if pause || len(chans) == 0 {
		memoryMsgChan = nil
		backendChan = nil
	} else {
		memoryMsgChan = t.memoryMsgChan
		backendChan = t.backend.ReadChan()
	}
	continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个case既处理topic的暂停也处理topic的恢复，&lt;code&gt;pause&lt;/code&gt;变量决定其究竟是哪一种操作。
Topic的暂停和恢复其实和topic的更新很像，根据是否暂停以及是否有channel来决定是否分配&lt;code&gt;memoryMsgChan&lt;/code&gt;和&lt;code&gt;backendChan&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;messagepump-函数的退出:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;messagePump&lt;/code&gt;函数的退出&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;case &amp;lt;-t.exitChan:
	goto exit

// ...
exit:
	t.ctx.nsqd.logf(&amp;quot;TOPIC(%s): closing ... messagePump&amp;quot;, t.name)
}
// End of messagePump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;messagePump&lt;/code&gt;通过监听&lt;code&gt;exitChan&lt;/code&gt;来获知topic是否被删除，当topic的删除时，跳转到函数的最后，输出日志后退出消息循环。&lt;/p&gt;

&lt;h1 id=&#34;topic的关闭和删除:efd667b960aa7ec362edb15e7af0b343&#34;&gt;Topic的关闭和删除&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Delete empties the topic and all its channels and closes
func (t *Topic) Delete() error {
	return t.exit(true)
}

// Close persists all outstanding topic data and closes all its channels
func (t *Topic) Close() error {
	return t.exit(false)
}

func (t *Topic) exit(deleted bool) error {
	if !atomic.CompareAndSwapInt32(&amp;amp;t.exitFlag, 0, 1) {
		return errors.New(&amp;quot;exiting&amp;quot;)
	}

	if deleted {
		t.ctx.nsqd.logf(&amp;quot;TOPIC(%s): deleting&amp;quot;, t.name)

		// since we are explicitly deleting a topic (not just at system exit time)
		// de-register this from the lookupd
		t.ctx.nsqd.Notify(t)
	} else {
		t.ctx.nsqd.logf(&amp;quot;TOPIC(%s): closing&amp;quot;, t.name)
	}

	close(t.exitChan)

	// synchronize the close of messagePump()
	t.waitGroup.Wait()

	if deleted {
		t.Lock()
		for _, channel := range t.channelMap {
			delete(t.channelMap, channel.name)
			channel.Delete()
		}
		t.Unlock()

		// empty the queue (deletes the backend files, too)
		t.Empty()
		return t.backend.Delete()
	}

	// close all the channels
	for _, channel := range t.channelMap {
		err := channel.Close()
		if err != nil {
			// we need to continue regardless of error to close all the channels
			t.ctx.nsqd.logf(&amp;quot;ERROR: channel(%s) close - %s&amp;quot;, channel.name, err)
		}
	}

	// write anything leftover to disk
	t.flush()
	return t.backend.Close()
}
// Exiting returns a boolean indicating if this topic is closed/exiting
func (t *Topic) Exiting() bool {
	return atomic.LoadInt32(&amp;amp;t.exitFlag) == 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Topic关闭和删除的实现都是调用&lt;code&gt;exit&lt;/code&gt;函数，只是传递的参数不同，删除时调用&lt;code&gt;exit(true)&lt;/code&gt;，关闭时调用&lt;code&gt;exit(false)&lt;/code&gt;。
&lt;code&gt;exit&lt;/code&gt;函数进入时通过&lt;code&gt;atomic.CompareAndSwapInt32&lt;/code&gt;函数判断当前是否正在退出，如果不是，则设置退出标记，对于已经在退出的topic，不再重复执行退出函数。
接着对于关闭操作，使用&lt;code&gt;Notify&lt;/code&gt;函数通知lookupd以便其他nsqd获知该消息。&lt;/p&gt;

&lt;p&gt;随后，&lt;code&gt;exit&lt;/code&gt;函数调用&lt;code&gt;close(t.exitChan)&lt;/code&gt;和&lt;code&gt;t.waitGroup.Wait()&lt;/code&gt;通知其他正在运行goroutine当前topic已经停止，并等待&lt;code&gt;waitGroup&lt;/code&gt;中的goroutine结束运行。&lt;/p&gt;

&lt;p&gt;最后，对于删除和关闭两种操作，执行不同的逻辑来完成最后的清理工作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于删除操作，需要清空&lt;code&gt;channelMap&lt;/code&gt;并删除所有channel，然后删除内存和磁盘中所有未投递的消息。最后关闭&lt;code&gt;backend&lt;/code&gt;管理的的磁盘文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于关闭操作，不清空&lt;code&gt;channelMap&lt;/code&gt;，只是关闭所有的channel，使用&lt;code&gt;flush&lt;/code&gt;函数将所有&lt;code&gt;memoryMsgChan&lt;/code&gt;中未投递的消息用&lt;code&gt;writeMessageToBackend&lt;/code&gt;保存到磁盘中。最后关闭&lt;code&gt;backend&lt;/code&gt;管理的的磁盘文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) flush() error {
	//...
	for {
		select {
		case msg := &amp;lt;-t.memoryMsgChan:
			err := writeMessageToBackend(&amp;amp;msgBuf, msg, t.backend)
			if err != nil {
				t.ctx.nsqd.logf(
					&amp;quot;ERROR: failed to write message to backend - %s&amp;quot;, err)
			}
		default:
			goto finish
		}
	}
	
finish:
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flush&lt;/code&gt;函数也使用到了default分支来检测是否已经处理完全部消息。
由于此时已经没有生产者向&lt;code&gt;memoryMsgChan&lt;/code&gt;提供消息，因此如果出现阻塞就表示消息已经处理完毕。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) Empty() error {
	for {
		select {
		case &amp;lt;-t.memoryMsgChan:
		default:
			goto finish
		}
	}

finish:
	return t.backend.Empty()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在删除topic时用到的&lt;code&gt;Empty&lt;/code&gt;函数跟&lt;code&gt;flush&lt;/code&gt;处理逻辑类似，只不过&lt;code&gt;Empty&lt;/code&gt;只释放&lt;code&gt;memoryMsgChan&lt;/code&gt;消息，而不保存它们。&lt;/p&gt;

&lt;h1 id=&#34;其他函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;其他函数&lt;/h1&gt;

&lt;h2 id=&#34;depth-函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;Depth&lt;/code&gt;函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) Depth() int64 {
	return int64(len(t.memoryMsgChan)) + t.backend.Depth()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Depth&lt;/code&gt;函数用于获取当前topic尚未投递的消息数，是&lt;code&gt;memoryMsgChan&lt;/code&gt;缓冲区的长度加上&lt;code&gt;backend&lt;/code&gt;里消息的个数。&lt;/p&gt;

&lt;h2 id=&#34;pause-和-unpause-函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;Pause&lt;/code&gt;和&lt;code&gt;UnPause&lt;/code&gt;函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (t *Topic) Pause() error {
	return t.doPause(true)
}

func (t *Topic) UnPause() error {
	return t.doPause(false)
}

func (t *Topic) doPause(pause bool) error {
	if pause {
		atomic.StoreInt32(&amp;amp;t.paused, 1)
	} else {
		atomic.StoreInt32(&amp;amp;t.paused, 0)
	}

	select {
	case t.pauseChan &amp;lt;- pause:
	case &amp;lt;-t.exitChan:
	}

	return nil
}

func (t *Topic) IsPaused() bool {
	return atomic.LoadInt32(&amp;amp;t.paused) == 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于很多相似的处理逻辑，nsqd在对外使用不同的函数，但在内部实现上通常把它们合并为一个函数来处理，只是传递的参数不同而已，
比如前面提到的&lt;code&gt;Close&lt;/code&gt;和&lt;code&gt;Delete&lt;/code&gt;。&lt;code&gt;Pause&lt;/code&gt;和&lt;code&gt;UnPause&lt;/code&gt;同样也使用这种方式，通过传递不同的参数调用&lt;code&gt;doPause&lt;/code&gt;函数来执行不同操作。
&lt;code&gt;doPause&lt;/code&gt;设置&lt;code&gt;paused&lt;/code&gt;标志并向&lt;code&gt;pauseChan&lt;/code&gt;发送消息，随后由&lt;code&gt;messagePump&lt;/code&gt;在消息循环中暂停topic。&lt;/p&gt;

&lt;h2 id=&#34;aggregatechannele2eprocessinglatency-函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;&lt;code&gt;AggregateChannelE2eProcessingLatency&lt;/code&gt;函数&lt;/h2&gt;

&lt;p&gt;此函数用于性能统计，在&lt;code&gt;nsqd/statd.go&lt;/code&gt;中调用，客户端可以通过HTTP的/stats API看到统计结果。具体细节将在后续博文分析。&lt;/p&gt;

&lt;h2 id=&#34;与channel相关的函数:efd667b960aa7ec362edb15e7af0b343&#34;&gt;与channel相关的函数&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;GetChannel&lt;/code&gt;, &lt;code&gt;getOrCreateChannel&lt;/code&gt;，&lt;code&gt;GetExistingChannel&lt;/code&gt;, &lt;code&gt;DeleteExistingChannel&lt;/code&gt;这些函数是与channel相关的函数，将在后续的博文中分析。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nsq源码阅读笔记之nsqd（一）——nsqd的配置解析和初始化</title>
      <link>http://blog.rayxxzhang.com/2015/11/12/nsqd-source-1-init/</link>
      <pubDate>Thu, 12 Nov 2015 22:50:13 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/11/12/nsqd-source-1-init/</guid>
      <description>

&lt;h1 id=&#34;配置解析:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;配置解析&lt;/h1&gt;

&lt;p&gt;nsqd的主函数位于&lt;code&gt;apps/nsqd.go&lt;/code&gt;中的&lt;code&gt;main&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;flagSet := nsqFlagset()
flagSet.Parse(os.Args[1:])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先&lt;code&gt;main&lt;/code&gt;函数调用&lt;code&gt;nsqFlagset&lt;/code&gt;和&lt;code&gt;Parse&lt;/code&gt;进行命令行参数集初始化，
然后判断&lt;code&gt;version&lt;/code&gt;参数是否存在，若存在，则打印版本号并退出程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;signalChan := make(chan os.Signal, 1)
signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)
//...
&amp;lt;-signalChan
nsqd.Exit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来钩住系统的&lt;code&gt;syscall.SIGINT&lt;/code&gt;和&lt;code&gt;syscall.SIGTERM&lt;/code&gt;消息，用来阻塞主goroutine防止退出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var cfg config
configFile := flagSet.Lookup(&amp;quot;config&amp;quot;).Value.String()
if configFile != &amp;quot;&amp;quot; {
	_, err := toml.DecodeFile(configFile, &amp;amp;cfg)
	if err != nil {
		log.Fatalf(&amp;quot;ERROR: failed to load config file %s - %s&amp;quot;, configFile, err.Error())
	}
}
cfg.Validate()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后判断&lt;code&gt;config&lt;/code&gt;参数是否存在，若存在的话还需进行配置文件的读取，
nsq使用toml格式的配置文件，并通过&lt;code&gt;github.com/BurntSushi/toml&lt;/code&gt;库进行配置文件的读取和解析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (cfg config) Validate() {
	// special validation/translation
	if v, exists := cfg[&amp;quot;tls_required&amp;quot;]; exists {
		var t tlsRequiredOption
		err := t.Set(fmt.Sprintf(&amp;quot;%v&amp;quot;, v))
		if err == nil {
			cfg[&amp;quot;tls_required&amp;quot;] = t.String()
		} else {
			log.Fatalf(&amp;quot;ERROR: failed parsing tls required %v&amp;quot;, v)
		}
	}
	if v, exists := cfg[&amp;quot;tls_min_version&amp;quot;]; exists {
		var t tlsVersionOption
		err := t.Set(fmt.Sprintf(&amp;quot;%v&amp;quot;, v))
		if err == nil {
			newVal := fmt.Sprintf(&amp;quot;%v&amp;quot;, t.Get())
			if newVal != &amp;quot;0&amp;quot; {
				cfg[&amp;quot;tls_min_version&amp;quot;] = newVal
			} else {
				delete(cfg, &amp;quot;tls_min_version&amp;quot;)
			}
		} else {
			log.Fatalf(&amp;quot;ERROR: failed parsing tls min version %v&amp;quot;, v)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果配置文件存在并且符合toml格式，则调用&lt;code&gt;cfg.Validate&lt;/code&gt;对配置文件的各项进行进一步的合法性检查。
主要是检查配置文件中有关tls的选项（是否支持以及支持的版本）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;opts := nsqd.NewOptions()
options.Resolve(opts, flagSet, cfg)
nsqd := nsqd.New(opts)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件检查通过后，创建默认配置&lt;code&gt;opts&lt;/code&gt;，并于命令行参数和配置文件进行合并。
合并时用到了&lt;code&gt;github.com/mreiferson/go-options&lt;/code&gt;库。
若出现冲突，则优先级从高到低排序依次是命令行、配置文件和默认配置
使用合并后的参数集初始化真正的nsqd对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;nsqd.LoadMetadata()
err := nsqd.PersistMetadata()
if err != nil {
	log.Fatalf(&amp;quot;ERROR: failed to persist metadata - %s&amp;quot;, err.Error())
}
nsqd.Main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，nsqd对象进行初始化和检查后，启动nsqd包的主函数，程序从跳转&lt;code&gt;apps/nsqd.go&lt;/code&gt;到&lt;code&gt;nsqd/nsqd.go&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;初始化:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;初始化&lt;/h1&gt;

&lt;p&gt;nsqd真正开始运行前需要执行&lt;code&gt;nsqd/nsqd.go&lt;/code&gt;中的&lt;code&gt;LoadMetadata&lt;/code&gt;和&lt;code&gt;PersistMetadata&lt;/code&gt;两个函数&lt;/p&gt;

&lt;h2 id=&#34;loadmetadata:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;LoadMetadata&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// nsqd/nsqd.go
atomic.StoreInt32(&amp;amp;n.isLoading, 1)
defer atomic.StoreInt32(&amp;amp;n.isLoading, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化nsqd的&lt;code&gt;LoadMetadata&lt;/code&gt;函数使用&lt;code&gt;atomic&lt;/code&gt;包中的方法来保证方法执行前和执行后&lt;code&gt;isLoading&lt;/code&gt;值的改变&lt;/p&gt;

&lt;p&gt;元数据以&lt;code&gt;json&lt;/code&gt;格式保存在nsqd可执行文件目录下的*nsqd.%d.dat*中。其中&lt;code&gt;%d&lt;/code&gt;为代表该程序的ID，
通过在启动时的命令行&lt;code&gt;worker-id&lt;/code&gt;或者配置文件中的&lt;code&gt;id&lt;/code&gt;指定。默认ID是通过对主机名散列后获得。
因此保证了同一台机器每次启动的ID相同。&lt;/p&gt;

&lt;p&gt;解析元数据的文件得到系统中的存在的topic列表，遍历topic列表中的每个topic：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;检查topic名称是否合法（长度在1-64之间，满足正则表达式&lt;code&gt;^[\.a-zA-Z0-9_-]+(#ephemeral)?$&lt;/code&gt;）
，若不合法则忽略&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;GetTopic&lt;/code&gt;函数通过名字获得topic对象&lt;/li&gt;
&lt;li&gt;判断当前topic对象是否处于暂停状态，是的话调用&lt;code&gt;Pause&lt;/code&gt;函数暂停topic&lt;/li&gt;
&lt;li&gt;获取当前topic下所有的channel，并且遍历channel，执行的操作与topic基本一致

&lt;ol&gt;
&lt;li&gt;检查channel名称是否合法（长度在1-64之间，满足正则表达式&lt;code&gt;^[\.a-zA-Z0-9_-]+(#ephemeral)?$&lt;/code&gt;）
，若不合法则忽略&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;GetChannel&lt;/code&gt;函数通过名字获得channel对象&lt;/li&gt;
&lt;li&gt;判断当前channel对象是否处于暂停状态，是的话调用&lt;code&gt;Pause&lt;/code&gt;函数暂停channel&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，元数据的载入完成&lt;/p&gt;

&lt;h2 id=&#34;persistmetadata:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;PersistMetadata&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;PersistMetadata&lt;/code&gt;将当前的topic和channel信息写入*nsqd.%d.dat*文件中,
主要步骤是忽略&lt;code&gt;#ephemeral&lt;/code&gt;结尾的topic和channel后将topic和channel列表json序列化后写回文件中&lt;/p&gt;

&lt;p&gt;写入文件时先创建扩展名为tmp的临时文件，写入内容后并保存后再调用&lt;code&gt;atomicRename&lt;/code&gt;函数将tmp文件重命名为*nsqd.%d.dat*。
其中&lt;code&gt;atomicRename&lt;/code&gt;函数在windows和其他操作系统下实现方式不同，分别位于&lt;code&gt;nsqd/rename_windows.go&lt;/code&gt;
和&lt;code&gt;rename.go&lt;/code&gt;中。在Linux下直接调用了&lt;code&gt;os.Rename&lt;/code&gt;函数，而Windows下则使用Win32 API实现了文件的重命名。
这是因为go的早期版本中Windows下调用&lt;code&gt;os.Rename&lt;/code&gt;函数时如果重命名后的文件已经存在则会失败。
这个bug在&lt;a href=&#34;https://github.com/golang/go/issues/8914&#34;&gt;os: make Rename atomic on Windows&lt;/a&gt;中提到，
并且已经在&lt;a href=&#34;https://github.com/golang/go/commit/92c57363e0b4d193c4324e2af6902fe56b7524a0&#34;&gt;os: windows Rename should overwrite destination file.&lt;/a&gt;提交中被修复，
因此，Golang1.5不存在这一bug&lt;/p&gt;

&lt;h2 id=&#34;main:e76b703d5211370058cbe6eb0135f2ee&#34;&gt;Main&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;Main&lt;/code&gt;函数中，nsqd真正开始运行。&lt;code&gt;Main&lt;/code&gt;监听tcp，https（如果设置了相关参数），http端口并通过&lt;code&gt;WaitGroupWrapper&lt;/code&gt;的&lt;code&gt;Wrap&lt;/code&gt;函数以goroutine方式启动主要的组件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type WaitGroupWrapper struct {
	sync.WaitGroup
}

func (w *WaitGroupWrapper) Wrap(cb func()) {
	w.Add(1)
	go func() {
		cb()
		w.Done()
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;WaitGroupWrapper&lt;/code&gt;是对&lt;code&gt;sync.WaitGroup&lt;/code&gt;的简单包装&lt;/p&gt;

&lt;p&gt;执行完&lt;code&gt;Main&lt;/code&gt;函数后，配置和初始化工作全部完成，各个组件启动运行，而主goroutine会阻塞在&lt;code&gt;&amp;lt;-signalChan&lt;/code&gt;处，直到收到中断程序的信号，随后执行&lt;code&gt;nsqd.Exit&lt;/code&gt;函数。
&lt;code&gt;Exit&lt;/code&gt;函数将进行&lt;code&gt;socket&lt;/code&gt;关闭等清理工作，随后结束整个程序的运行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang实现带优先级的channel</title>
      <link>http://blog.rayxxzhang.com/2015/10/29/golang_priority_channel/</link>
      <pubDate>Thu, 29 Oct 2015 15:32:52 +0800</pubDate>
      
      <guid>http://blog.rayxxzhang.com/2015/10/29/golang_priority_channel/</guid>
      <description>&lt;p&gt;一般Go语言同时使用多个&lt;code&gt;channel&lt;/code&gt;的方法是使用&lt;code&gt;select&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;语句配合&lt;code&gt;&amp;lt;-&lt;/code&gt;操作符，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
case &amp;lt;- chan1:
	// do something
case &amp;lt;- chan2:
	// do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这种实现方式下&lt;code&gt;chan1&lt;/code&gt;和&lt;code&gt;chan2&lt;/code&gt;是同等优先级的。如果要实现带优先级的&lt;code&gt;channel&lt;/code&gt;则需要用到&lt;code&gt;defalut&lt;/code&gt;语句。&lt;/p&gt;

&lt;p&gt;在go语言中，如果&lt;code&gt;select&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;中没有&lt;code&gt;default&lt;/code&gt;子句，则程序会阻塞在&lt;code&gt;select&lt;/code&gt;中，直到其中一个&lt;code&gt;case&lt;/code&gt;语句接收到了数据。
如果有&lt;code&gt;default&lt;/code&gt;语句，则不会阻塞，如果&lt;code&gt;case&lt;/code&gt;接收到数据，就执行&lt;code&gt;case&lt;/code&gt;中的语句，如果&lt;code&gt;case&lt;/code&gt;未收到信号，则会执行&lt;code&gt;defalut&lt;/code&gt;中的语句，随后跳出&lt;code&gt;select&lt;/code&gt;块。&lt;/p&gt;

&lt;p&gt;使用这个特性可以实现带优先级的&lt;code&gt;channel&lt;/code&gt;队列。以2个优先级的&lt;code&gt;channel&lt;/code&gt;举例，实现方法是使用多层&lt;code&gt;select&lt;/code&gt;，将高优先级&lt;code&gt;channel&lt;/code&gt;放在最外层&lt;code&gt;select&lt;/code&gt;语句的&lt;code&gt;case&lt;/code&gt;后，并跟上一个&lt;code&gt;default&lt;/code&gt;语句以免当高优先级的&lt;code&gt;channel&lt;/code&gt;没有数据时阻塞。
&lt;code&gt;defalut&lt;/code&gt;内依然是一个&lt;code&gt;select&lt;/code&gt;语句，在这个&lt;code&gt;select&lt;/code&gt;语句中，将高优先级和低优先级的&lt;code&gt;case&lt;/code&gt;都放入，并且没有&lt;code&gt;default&lt;/code&gt;语句。这样内层&lt;code&gt;select&lt;/code&gt;就会阻塞直到其中一个&lt;code&gt;case&lt;/code&gt;收到数据。&lt;/p&gt;

&lt;p&gt;这种实现方式相当于高优先级的&lt;code&gt;channel&lt;/code&gt;比低优先级的多了一次被处理的机会，即外层&lt;code&gt;select&lt;/code&gt;，只有高优先级没有数据时，才会执行内层&lt;code&gt;select&lt;/code&gt;，此时先产生数据的&lt;code&gt;channel&lt;/code&gt;先被执行。&lt;/p&gt;

&lt;p&gt;也就是说，当高优先级和低优先级都有数据时，高优先级先被处理，也就是实现了优先级。示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for {
	select {
	case data := &amp;lt;- highChan:
		handleHigh(data)
	default:
		select {
		case data := &amp;lt;- highChan:
			handleHigh(data)
		case data := &amp;lt;- lowChan:
			handleLow(data)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>